ä¸€ã€ç°æœ‰æŠ“å–å®ç°ï¼ˆä»£ç å¼•ç”¨ï¼‰

å†™å…¥ JSONL ä¸æ–‡ä»¶å‡†å¤‡
function appendJSONL(record) {

&nbsp; try {

&nbsp;   fs.appendFileSync(OUTPUT\_FILE, JSON.stringify(record) + '\\n');

&nbsp; } catch (e) {

&nbsp;   // å¿½ç•¥ç¬æ—¶å†™å…¥é”™è¯¯

&nbsp; }

}



function ensureOutputFile() {

&nbsp; try {

&nbsp;   if (!fs.existsSync(OUTPUT\_FILE)) {

&nbsp;     fs.writeFileSync(OUTPUT\_FILE, '');

&nbsp;   }

&nbsp; } catch {}

}

æ³¨å…¥è„šæœ¬ï¼šæŠ½å–æ¶ˆæ¯å¹¶å½¢æˆå¿«ç…§ payloadï¼ˆé‡ç‚¹ï¼šmessages æ•°ç»„ã€chatKey/chatId/chatTitleï¼‰

&nbsp;       const items = pickAllDeep(ITEM\_SELECTORS, root);

&nbsp;       console.log(MARK + 'DEBUG', `found ${items.length} raw message items.`);

&nbsp;       const slice = items.slice(Math.max(0, items.length - SAMPLE));

&nbsp;       const msgs = \[];

&nbsp;       for (const el of slice) {

&nbsp;         if (!(el instanceof HTMLElement)) continue;

&nbsp;         let text = extractText(el);

&nbsp;         if (!looksLikeMsg(text)) {

&nbsp;           const label = detectMedia(el);

&nbsp;           if (label) text = label; else continue;

&nbsp;         }

&nbsp;         msgs.push({

&nbsp;           text: text.substring(0, 500),

&nbsp;           isOut: isOut(el)

&nbsp;         });

&nbsp;       }

&nbsp;       console.log(MARK + 'DEBUG', `processed ${msgs.length} messages in ${Date.now() - t\_start}ms`);



&nbsp;       // å¦‚æœæ²¡æ‰¾åˆ°æ¶ˆæ¯ï¼Œä½†æ‰¾åˆ°äº†æ ¹ï¼Œåˆ™å¯èƒ½é€‰æ‹©å™¨ä¸å¯¹ï¼Œå›ä¼  DOM ç»“æ„ä¾›åˆ†æ

&nbsp;       if (msgs.length === 0 \&\& items.length > 0) {

&nbsp;         try {

&nbsp;           const sampleHTML = Array.from(slice).slice(-1)\[0].outerHTML;

&nbsp;           console.log(MARK + 'DEBUG', 'No msgs extracted, last item HTML:', sampleHTML.substring(0, 800));

&nbsp;         } catch {}

&nbsp;       }



&nbsp;       const payload = {

&nbsp;         kind: 'snapshot',

&nbsp;         reason,

&nbsp;         accountId: ${JSON.stringify(accountId)},

&nbsp;         chatKey: getChatKey(),

&nbsp;         chatId: getChatId(),

&nbsp;         chatTitle: getChatTitle(),

&nbsp;         ts: Date.now(),

&nbsp;         messages: msgs

&nbsp;       };

&nbsp;       try { window.\_\_tg\_last = payload; } catch {}

&nbsp;       try { console.log(MARK + JSON.stringify(payload)); } catch {}

&nbsp;       return payload;

è¿æ¥ç›®æ ‡é¡µã€æ³¨å…¥è„šæœ¬å¹¶ç›‘å¬æ§åˆ¶å°äº‹ä»¶

&nbsp;     const targetOption = target.webSocketDebuggerUrl || target.id || target.targetId;

&nbsp;     const client = await CDP({ host: '127.0.0.1', port, target: targetOption });

&nbsp;     const { Runtime, Page } = client;

&nbsp;     await Page.enable();

&nbsp;     await Runtime.enable();



&nbsp;     // è½¬å‘é¡µé¢å†…çš„å¿«ç…§æ—¥å¿—

&nbsp;     Runtime.consoleAPICalled((evt) => {

&nbsp;       try {

&nbsp;         function unwrapDevtoolsString(s){

&nbsp;           if (typeof s !== 'string') return String(s);

&nbsp;           try { return JSON.parse(s); } catch { return s; }

&nbsp;         }

&nbsp;         function getArgText(a){

&nbsp;           let raw = (a \&\& a.value !== undefined) ? a.value :

&nbsp;                     (a \&\& a.unserializableValue !== undefined) ? a.unserializableValue :

&nbsp;                     (a \&\& a.description) ? a.description : '';

&nbsp;           return unwrapDevtoolsString(raw);

&nbsp;         }

&nbsp;         const args = evt.args || \[];

&nbsp;         const textValues = args.map(getArgText);

&nbsp;         const joined = textValues.join(' ');

&nbsp;         const tgrtIndex = joined.indexOf('\[TGRT]');



&nbsp;         if (tgrtIndex !== -1) {

&nbsp;           // ä¼˜å…ˆå¤„ç† JSON payload

&nbsp;           if (textValues.length > 1 \&\& textValues\[0] === '\[TGRT]' \&\& textValues\[1] \&\& textValues\[1].startsWith('{')) {

&nbsp;             const json = textValues\[1];

&nbsp;             console.log(`\[TGRT-CAPTURE] ${json.substring(0,180)}`);

&nbsp;             try {

&nbsp;               const data = JSON.parse(json);

&nbsp;               appendJSONL({

&nbsp;                 source: 'telegram',

&nbsp;                 accountId: data.accountId || target.accountId,

&nbsp;                 chatKey: data.chatKey || '',

&nbsp;                 chatId: data.chatId || '',

&nbsp;                 chatTitle: data.chatTitle || '',

&nbsp;                 ts: Date.now(),

&nbsp;                 reason: data.reason,

&nbsp;                 messages: data.messages || \[],

&nbsp;               });

&nbsp;             } catch (e) {

&nbsp;               console.log(`âš ï¸ TGRT JSON è§£æå¤±è´¥: ${e.message}`);

&nbsp;             }

&nbsp;           } else if (textValues.some(t => typeof t === 'string' \&\& t.includes('\[TGRT]DEBUG'))) {

&nbsp;             // å…¶æ¬¡å¤„ç† DEBUG æ—¥å¿—

&nbsp;             console.log(`\[TG-DEBUGGER]\[${target.accountId}] ${joined}`);

&nbsp;           } else {

&nbsp;             // å…¼å®¹æ—§æ ¼å¼

&nbsp;             const markerSlice = joined.slice(tgrtIndex);

&nbsp;             console.log(`\[TGRT-CAPTURE] ${markerSlice.slice(0, 160)}`);

&nbsp;             const json = markerSlice.slice(6).trim();

&nbsp;             try {

&nbsp;               const data = JSON.parse(json);

&nbsp;               appendJSONL({

&nbsp;                 source: 'telegram',

&nbsp;                 accountId: data.accountId || target.accountId,

&nbsp;                 chatKey: data.chatKey || '',

&nbsp;                 chatId: data.chatId || '',

&nbsp;                 chatTitle: data.chatTitle || '',

&nbsp;                 ts: Date.now(),

&nbsp;                 reason: data.reason,

&nbsp;                 messages: data.messages || \[],

&nbsp;               });

&nbsp;             } catch (e) {

&nbsp;               console.log(`âš ï¸ TGRT JSON(legacy)è§£æå¤±è´¥: ${e.message}`);

&nbsp;             }

&nbsp;           }

&nbsp;         }

&nbsp;       } catch {}

&nbsp;     });



&nbsp;     const expr = buildInjectionScript(target.accountId, 6);

&nbsp;     try {

&nbsp;       // è¯Šæ–­å·²ç¡®è®¤æ— éœ€å…³å¿ƒ frameï¼Œç›´æ¥åœ¨ç›®æ ‡ page ä¸Šä¸‹æ–‡æ³¨å…¥

&nbsp;       await Runtime.evaluate({ expression: expr, returnByValue: true });

&nbsp;       console.log(`âœ… å®æ—¶ç›‘å¬å°±ç»ª: ${target.accountId} @ ${target.url.substring(0, 40)}`);



&nbsp;       // è§¦å‘ä¸€æ¬¡æ‰‹åŠ¨å¿«ç…§ï¼Œç¡®ä¿é¦–è¡Œå†™å…¥ä¸é€šé“å¯ç”¨

&nbsp;       try {

&nbsp;         const kick = `(() => { try { if (window.\_\_tg\_snapshot\_\_) window.\_\_tg\_snapshot\_\_('manual'); } catch (e) {} return 'ok'; })()`;

&nbsp;         await Runtime.evaluate({ expression: kick, returnByValue: true });

&nbsp;       } catch {}

é¦–æ¬¡å¿«ç…§å†™å…¥ï¼ˆæœ‰/ç©ºï¼‰ä¸å…œåº•è¯»å–

&nbsp;       // è¯»å–ä¸€æ¬¡å¿«ç…§ç»“æœå¹¶ç›´æ¥å†™å…¥ï¼ˆå³ä½¿ console äº‹ä»¶æœªåˆ°è¾¾ï¼‰

&nbsp;       try {

&nbsp;         const collect = `(() => {\\n`+

&nbsp;           `  try {\\n`+

&nbsp;           `    const fn = (typeof window.\_\_tg\_collect\_\_==='function') ? window.\_\_tg\_collect\_\_ : null;\\n`+

&nbsp;           `    const data = fn ? fn('probe') : (window.\_\_tg\_last || null);\\n`+

&nbsp;           `    return JSON.stringify(data);\\n`+

&nbsp;           `  } catch(e){ return '\_\_ERR\_\_'+String(e \&\& e.message || e) }\\n`+

&nbsp;           `})()`;

&nbsp;         const ev = await Runtime.evaluate({ expression: collect, returnByValue: true });

&nbsp;         const s = ev \&\& ev.result \&\& ev.result.value;

&nbsp;         let wrote = false;

&nbsp;         if (typeof s === 'string' \&\& s \&\& !s.startsWith('\_\_ERR\_\_')) {

&nbsp;           try {

&nbsp;             const val = JSON.parse(s);

&nbsp;             if (val \&\& val.kind === 'snapshot' \&\& Array.isArray(val.messages)) {

&nbsp;               appendJSONL({

&nbsp;                 source: 'telegram',

&nbsp;                 accountId: val.accountId || target.accountId,

&nbsp;                 chatKey: val.chatKey || '',

&nbsp;                 chatId: val.chatId || '',

&nbsp;                 chatTitle: val.chatTitle || '',

&nbsp;                 ts: Date.now(),

&nbsp;                 reason: val.reason || 'probe',

&nbsp;                 messages: Array.isArray(val.messages) ? val.messages : \[]

&nbsp;               });

&nbsp;               console.log(`ğŸ“ é¦–æ¬¡å¿«ç…§å·²å†™å…¥: ${target.accountId}`);

&nbsp;               wrote = true;

&nbsp;             } else if (val \&\& val.messages \&\& val.messages.length === 0) {

&nbsp;               // å³ä½¿æ¶ˆæ¯ä¸ºç©ºï¼Œä¹Ÿå†™å…¥ä¸€æ¡è®°å½•è¡¨ç¤ºå·²æ¿€æ´»

&nbsp;               appendJSONL({

&nbsp;                 source: 'telegram',

&nbsp;                 accountId: val.accountId || target.accountId,

&nbsp;                 chatKey: val.chatKey || '',

&nbsp;                 chatId: val.chatId || '',

&nbsp;                 chatTitle: val.chatTitle || '',

&nbsp;                 ts: Date.now(),

&nbsp;                 reason: val.reason || 'probe\_empty',

&nbsp;                 messages: \[]

&nbsp;               });

&nbsp;               console.log(`ğŸ“ é¦–æ¬¡å¿«ç…§(ç©º)å·²å†™å…¥: ${target.accountId}`);

&nbsp;               wrote = true;

&nbsp;             }

&nbsp;           } catch (e) {

&nbsp;             console.log(`âš ï¸ é¦–æ¬¡é‡‡é›†è§£æå¤±è´¥: ${e.message}`);

&nbsp;           }

&nbsp;         }

-------------------------------------------------------------------------------------------------------------------

          if (!wrote) {

&nbsp;           // å…œåº•ï¼šè¯»å– window.\_\_tg\_last

&nbsp;           try {

&nbsp;             const pickLast = `(() => {\\n`+

&nbsp;               `  try { return JSON.stringify(window.\_\_tg\_last || null) } catch(e){ return '\_\_ERR\_\_'+String(e \&\& e.message || e) }\\n`+

&nbsp;               `})()`;

&nbsp;             const ev2 = await Runtime.evaluate({ expression: pickLast, returnByValue: true });

&nbsp;             const s2 = ev2 \&\& ev2.result \&\& ev2.result.value;

&nbsp;             if (typeof s2 === 'string' \&\& s2 \&\& !s2.startsWith('\_\_ERR\_\_')) {

&nbsp;               try {

&nbsp;                 const val2 = JSON.parse(s2);

&nbsp;                 if (val2 \&\& val2.kind === 'snapshot' \&\& Array.isArray(val2.messages)) {

&nbsp;                   appendJSONL({

&nbsp;                     source: 'telegram',

&nbsp;                     accountId: val2.accountId || target.accountId,

&nbsp;                     chatKey: val2.chatKey || '',

&nbsp;                     chatId: val2.chatId || '',

&nbsp;                     chatTitle: val2.chatTitle || '',

&nbsp;                     ts: Date.now(),

&nbsp;                     reason: val2.reason || 'init',

&nbsp;                     messages: Array.isArray(val2.messages) ? val2.messages : \[]

&nbsp;                   });

&nbsp;                   console.log(`ğŸ“ é¦–æ¬¡å¿«ç…§(å…œåº•)å·²å†™å…¥: ${target.accountId}`);

&nbsp;                   wrote = true;

&nbsp;                 }

&nbsp;               } catch {}

&nbsp;             }

&nbsp;           } catch {}

&nbsp;         }

&nbsp;         if (!wrote) {

&nbsp;           console.log(`â„¹ï¸ é¦–æ¬¡é‡‡é›†ä¸ºç©º: ${target.accountId}`);

&nbsp;         }

äºŒã€æ•°æ®åº“å­˜å‚¨ä¸è‡ªåŠ¨å»é‡ï¼ˆæ–°å¢å®ç°ï¼‰

ç›®æ ‡ï¼šåœ¨ä¿æŒ JSONL è¾“å‡ºä¸å˜çš„åŸºç¡€ä¸Šï¼Œå°†åŒæ ·çš„å¿«ç…§æ•°æ®å…¥åº“ï¼Œå¹¶å¯¹æ¶ˆæ¯åšå¹‚ç­‰å»é‡ã€‚å»é‡ä¼˜å…ˆä½¿ç”¨ DOM æå–çš„æ¶ˆæ¯ IDï¼ˆè‹¥æ— åˆ™ä½¿ç”¨â€œæ–‡æœ¬å“ˆå¸Œ + æ—¶é—´çª—å£â€ç­–ç•¥ï¼‰ã€‚

ä¾èµ–å®‰è£…
npm i better-sqlite3


æ–°å¢ï¼šæ•°æ®åº“åˆå§‹åŒ–ã€è¡¨ç»“æ„ã€å»é‡ä¸å†™å…¥å‡½æ•°

å°†ä»¥ä¸‹ä»£ç æ·»åŠ åˆ° resources/app/client/src/preload/tg-realtime-capture.js é¡¶éƒ¨ require ä¹‹åï¼š

const crypto = require('crypto');



// ---- DB: SQLite (better-sqlite3) ----

let db = null;

let insertMessageStmt = null;

let ensureSchemaDone = false;



function initDB() {

&nbsp; if (ensureSchemaDone) return;

&nbsp; let Database;

&nbsp; try {

&nbsp;   Database = require('better-sqlite3');

&nbsp; } catch (e) {

&nbsp;   console.log('âš ï¸ æœªå®‰è£… better-sqlite3ï¼Œè·³è¿‡å…¥åº“ã€‚', e.message);

&nbsp;   ensureSchemaDone = true;

&nbsp;   return;

&nbsp; }

&nbsp; const dbPath = path.resolve(process.cwd(), 'traneasy.db');

&nbsp; db = new Database(dbPath);

&nbsp; db.pragma('journal\_mode = WAL');

&nbsp; db.exec(`

&nbsp;   CREATE TABLE IF NOT EXISTS chat\_messages (

&nbsp;     id INTEGER PRIMARY KEY AUTOINCREMENT,

&nbsp;     source TEXT NOT NULL,

&nbsp;     accountId TEXT NOT NULL,

&nbsp;     chatKey TEXT NOT NULL,

&nbsp;     chatId TEXT,

&nbsp;     chatTitle TEXT,

&nbsp;     isOut INTEGER NOT NULL,

&nbsp;     messageId TEXT,

&nbsp;     text TEXT NOT NULL,

&nbsp;     textHash TEXT NOT NULL,

&nbsp;     dedupKey TEXT NOT NULL,

&nbsp;     reason TEXT,

&nbsp;     ts INTEGER NOT NULL,

&nbsp;     insertedAt INTEGER NOT NULL DEFAULT (strftime('%s','now')\*1000)

&nbsp;   );

&nbsp;   CREATE UNIQUE INDEX IF NOT EXISTS ux\_chat\_messages\_dedup

&nbsp;     ON chat\_messages (source, accountId, chatKey, dedupKey);

&nbsp; `);

&nbsp; insertMessageStmt = db.prepare(`

&nbsp;   INSERT OR IGNORE INTO chat\_messages

&nbsp;     (source, accountId, chatKey, chatId, chatTitle, isOut, messageId, text, textHash, dedupKey, reason, ts)

&nbsp;   VALUES

&nbsp;     (@source, @accountId, @chatKey, @chatId, @chatTitle, @isOut, @messageId, @text, @textHash, @dedupKey, @reason, @ts)

&nbsp; `);

&nbsp; ensureSchemaDone = true;

}



function sha1(s) {

&nbsp; return crypto.createHash('sha1').update(String(s), 'utf8').digest('hex');

}



const DEDUP\_WINDOW\_MS = 180000; // 3åˆ†é’Ÿæ—¶é—´æ¡¶ï¼Œé¿å…å¿«ç…§é‡å¤



function persistSnapshotToDB(payload) {

&nbsp; if (!payload || !Array.isArray(payload.messages) || !payload.messages.length) return;

&nbsp; try { initDB(); } catch {}

&nbsp; if (!db || !insertMessageStmt) return;



&nbsp; const base = {

&nbsp;   source: 'telegram',

&nbsp;   accountId: payload.accountId || '',

&nbsp;   chatKey: payload.chatKey || '',

&nbsp;   chatId: payload.chatId || '',

&nbsp;   chatTitle: payload.chatTitle || '',

&nbsp;   reason: payload.reason || ''

&nbsp; };

&nbsp; const ts = typeof payload.ts === 'number' ? payload.ts : Date.now();

&nbsp; const bucket = Math.floor(ts / DEDUP\_WINDOW\_MS);



&nbsp; const rows = payload.messages.map(m => {

&nbsp;   const text = (m \&\& m.text ? String(m.text).slice(0, 1000) : '');

&nbsp;   const textHash = sha1(text);

&nbsp;   const rawId = (m \&\& (m.id || m.messageId)) ? String(m.id || m.messageId) : '';

&nbsp;   const isOut = m \&\& m.isOut ? 1 : 0;

&nbsp;   const dedupUnit = rawId ? ('id:' + rawId) : ('t:' + textHash + ':b' + bucket);

&nbsp;   const dedupKey = sha1(base.source + '|' + base.accountId + '|' + base.chatKey + '|' + isOut + '|' + dedupUnit);

&nbsp;   return {

&nbsp;     ...base,

&nbsp;     isOut,

&nbsp;     messageId: rawId,

&nbsp;     text,

&nbsp;     textHash,

&nbsp;     dedupKey,

&nbsp;     ts

&nbsp;   };

&nbsp; });



&nbsp; try {

&nbsp;   const tx = db.transaction((arr) => {

&nbsp;     for (const r of arr) insertMessageStmt.run(r);

&nbsp;   });

&nbsp;   tx(rows);

&nbsp; } catch (e) {

&nbsp;   console.log('âš ï¸ æ•°æ®åº“å†™å…¥å¤±è´¥:', e.message);

&nbsp; }

}

æ–°å¢ï¼šåœ¨æ³¨å…¥è„šæœ¬ä¸­äº§å‡º messageIdï¼ˆæ›´å¼ºå»é‡ï¼‰

åœ¨ buildInjectionScript(...) çš„è„šæœ¬å­—ç¬¦ä¸²ä¸­ï¼Œè¡¥å…… getId å¹¶æŠŠ id å¸¦åˆ° msgs.push(...)ï¼š

// åœ¨ extractText / detectMedia ä¹‹åå¢åŠ ï¼š

function getId(el){

&nbsp; try {

&nbsp;   const a = el.getAttribute \&\& (el.getAttribute('data-message-id') || el.getAttribute('data-id'));

&nbsp;   return a ? String(a) : '';

&nbsp; } catch { return ''; }

}



// å°† msgs.push æ”¹ä¸ºï¼š

msgs.push({

&nbsp; id: getId(el),

&nbsp; text: text.substring(0, 500),

&nbsp; isOut: isOut(el)

});

æ–°å¢ï¼šåœ¨æ‰€æœ‰å†™ JSONL çš„ä½ç½®ï¼ŒåŒæ—¶è°ƒç”¨å…¥åº“

åœ¨ä¸‰ä¸ªä½ç½®è¿½åŠ è°ƒç”¨ persistSnapshotToDB(...)ï¼ˆç´§è·Ÿ appendJSONL(...) ä¹‹åï¼‰ï¼š

1\) æ§åˆ¶å°å®æ—¶äº‹ä»¶ï¼ˆä¼˜å…ˆ JSON payload åˆ†æ”¯ï¼‰

appendJSONL({ /\*...\*/ });

persistSnapshotToDB(data);

2) æ§åˆ¶å°å®æ—¶äº‹ä»¶ï¼ˆå…¼å®¹æ—§æ ¼å¼åˆ†æ”¯ï¼‰
appendJSONL({ /\*...\*/ });

persistSnapshotToDB(data);

3\) é¦–æ¬¡å¿«ç…§å†™å…¥ï¼ˆprobe/init ä¸¤å¤„ï¼‰

appendJSONL({ /\*...\*/ });

persistSnapshotToDB(val);   // æˆ– persistSnapshotToDB(val2);

ä¸‰ã€è¿è¡Œä¸é…ç½®

å¯åŠ¨å¸¦è¿œç¨‹è°ƒè¯•ç«¯å£çš„ç›®æ ‡æµè§ˆå™¨åï¼Œæ‰§è¡Œï¼š
node resources/app/client/src/preload/tg-realtime-capture.js

æ–‡ä»¶è¾“å‡ºï¼štg-realtime.jsonl

æ•°æ®åº“æ–‡ä»¶ï¼štraneasy.db

å¦‚æœªå®‰è£… better-sqlite3ï¼Œä¼šä»…è¾“å‡º JSONL å¹¶æç¤ºâ€œè·³è¿‡å…¥åº“â€ã€‚

å››ã€æ•°æ®è¡¨ç»“æ„ä¸å»é‡ç­–ç•¥

è¡¨ï¼šchat\_messages

å”¯ä¸€é”®ï¼š(source, accountId, chatKey, dedupKey)

dedupKey æ„é€ 

ä¼˜å…ˆ idï¼šsha1(source|accountId|chatKey|isOut|id:<messageId>)

æ—  idï¼šsha1(source|accountId|chatKey|isOut|t:<textHash>:b<timeBucket>)

æ—¶é—´æ¡¶ï¼š3 åˆ†é’Ÿï¼ˆå¯æŒ‰éœ€è°ƒæ•´ DEDUP\_WINDOW\_MSï¼‰


äº”ã€éªŒæ”¶ä¸æµ‹è¯•

åŠŸèƒ½éªŒè¯

èŠå¤©æ”¶åˆ°æ–°æ¶ˆæ¯åï¼Œåº”è§‚å¯Ÿåˆ° tg-realtime.jsonl æŒ‰è¡Œè¿½åŠ ã€‚

æ•°æ®åº“ç”Ÿæˆ traneasy.dbï¼Œå¹¶éšç€æ¶ˆæ¯å¢é•¿ã€‚

å»é‡éªŒè¯ï¼ˆç¤ºä¾‹ SQLï¼‰

SELECT COUNT(\*) AS n, chatKey, text

FROM chat\_messages

GROUP BY chatKey, text

ORDER BY n DESC

LIMIT 20;

æ€§èƒ½å»ºè®®

PRAGMA journal\_mode=WAL å·²å¼€å¯ï¼Œé€‚åˆå¤šæ¬¡çŸ­äº‹åŠ¡ã€‚

å¦‚é«˜å¹¶å‘å…¥åº“ï¼Œå»ºè®®æ‰¹é‡æäº¤ï¼ˆæ­¤å¤„å·²ç”¨äº‹åŠ¡åŒ…è£¹æ‰¹é‡è¡Œï¼‰ã€‚

å…­ã€å¸¸è§é—®é¢˜

æœªæ•è·åˆ° messageIdï¼šç•Œé¢ DOM æœªæš´éœ² data-message-idã€‚å·²å›é€€ä¸ºâ€œæ–‡æœ¬å“ˆå¸Œ + æ—¶é—´æ¡¶â€å»é‡ï¼Œå°½é‡é¿å…å¿«ç…§é‡å¤ã€‚

DB æ¨¡å—ç¼–è¯‘å¤±è´¥ï¼ˆWindowsï¼‰ï¼šå»ºè®®å®‰è£… VS Build Tools æˆ–ä½¿ç”¨é¢„ç¼–è¯‘ç‰ˆæœ¬ï¼›äº¦å¯æ”¹ç”¨çº¯ JS åµŒå…¥å¼åº“ï¼ˆå¦‚ nedbï¼‰ä½†æ€§èƒ½è¾ƒå¼±ã€‚

å¤šè´¦å·åœºæ™¯ï¼šaccountId + chatKey å·²ç”¨äºåŒºåˆ†åŒåèŠå¤©ä¸Šä¸‹æ–‡ã€‚



