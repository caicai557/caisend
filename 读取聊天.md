用“自动探测 CDP 端口 + 自动定位 Telegram 页”的方式，让你的工具无需手动配置就能接入易翻译并实时取消息。
思路
自动扫描常用 CDP 端口(9222-9333)，检测哪一个开放了 DevTools 接口。
读取该端口的目标列表，筛选 web.telegram.org/(a|k)/ 页签。
连接该目标，注入 DOM 消息提取器，定时拉取新消息，用于推荐回复。
最小可用脚本（Node）

npm i chrome-remote-interface node-fetch@2

// auto-discover + realtime messages
const CDP = require('chrome-remote-interface');
const fetch = require('node-fetch');

const PORTS = Array.from({length: 112}, (_,i)=>9222+i); // 9222-9333
const TGT = /https:\/\/web\.telegram\.org\/(a|k)\//;

async function probePort(p){
  try{
    const r = await fetch(`http://127.0.0.1:${p}/json/version`, {timeout: 600});
    if (!r.ok) return null;
    const j = await r.json();
    return j.webSocketDebuggerUrl ? p : null;
  }catch{ return null; }
}

async function findCDPPort(){
  const jobs = PORTS.map(probePort);
  const results = await Promise.all(jobs);
  return results.find(Boolean) || null;
}

async function findTelegramTarget(port){
  const r = await fetch(`http://127.0.0.1:${port}/json/list`);
  const list = await r.json();
  return list.find(t => TGT.test(t.url)) || null;
}

const INJECT = `
(function () {
  if (window.traneasy && window.traneasy.telegramRT) return 'ok';
  const ITEM_SELECTORS=['[data-message-id]','.message','.Message','.bubble','[class*="message"]'];
  const TEXT_SELECTORS=['.message-text','.text-content','[class*="text"]','[dir="auto"]'];
  function pickAll(s,root){root=root||document;const out=[];for(const x of s) out.push(...root.querySelectorAll(x));return Array.from(new Set(out));}
  function getText(el){for(const s of TEXT_SELECTORS){const n=el.querySelector(s);const t=n&&n.innerText&&n.innerText.trim();if(t) return t;}return (el.innerText||el.textContent||'').trim();}
  function isOut(el){const cls=((el.className||'')+' '+(el.parentElement&&el.parentElement.className||'')).toString();return /(\\bout|\\bown|outgoing|is-out|message-out)\\b/i.test(cls)||el.getAttribute('data-out')==='true';}
  function getId(el){return (el.getAttribute && el.getAttribute('data-message-id')) || '';}
  const queue=[], seen=new Set();
  const obs=new MutationObserver(ms=>{
    for(const m of ms){
      for(const node of m.addedNodes||[]){
        if(!(node instanceof HTMLElement)) continue;
        const cands=[node,...pickAll(ITEM_SELECTORS,node)];
        for(const el of cands){
          if(!(el instanceof HTMLElement)) continue;
          const text=getText(el); if(!text) continue;
          const id=getId(el) || ((isOut(el)?'1:':'0:')+text.slice(0,80));
          if(seen.has(id)) continue;
          seen.add(id); queue.push({id,text,isOut:isOut(el),ts:Date.now()});
          setTimeout(()=>seen.delete(id),3000);
        }
      }
    }
  });
  obs.observe(document.body,{childList:true,subtree:true});
  window.traneasy=window.traneasy||{};
  window.traneasy.telegramRT={ getNew:()=>queue.splice(0,queue.length) };
  return 'ok';
})();
`;

function suggest(text){
  if(/你好|您好/.test(text)) return '您好，请问需要什么帮助？';
  if(/价格|费用|报价/.test(text)) return '我们稍后会发您一份报价与方案。';
  if(/怎么|如何|帮助/.test(text)) return '方便具体说下问题，我来协助处理。';
  return '收到，我这边马上处理～';
}

(async()=>{
  let port = await findCDPPort();
  if(!port){ console.error('未发现 DevTools 端口（请用 --remote-debugging-port 启动或改为自动启动流程）'); process.exit(1); }
  const target = await findTelegramTarget(port);
  if(!target){ console.error('未找到 Telegram 页（请在易翻译中打开 Telegram 服务页）'); process.exit(1); }
  const client = await CDP({target, port});
  const {Runtime} = client;
  await Runtime.evaluate({expression: INJECT, returnByValue: true});
  setInterval(async()=>{
    try{
      const expr = `(function(){try{var a=(window.traneasy&&window.traneasy.telegramRT&&window.traneasy.telegramRT.getNew&&window.traneasy.telegramRT.getNew())||[];return JSON.stringify(a);}catch(e){return "[]";}})()`;
      const res = await Runtime.evaluate({expression: expr, returnByValue: true});
      const arr = JSON.parse(res.result.value || '[]');
      for(const m of arr){
        if(m.isOut) continue; // 仅入站
        const rec = suggest(m.text||'');
        console.log('[IN]', m.text, '\\n> 推荐：', rec, '\\n');
      }
    }catch{}
  }, 300);
})();

注意
如果易翻译未以 CDP 端口启动，无法发现端口；建议用你的启动器加一个优先级：先扫描端口→若没找到则带 --remote-debugging-port=<端口> 启动→再连接。
8085 报错是应用内部服务端口冲突，与 CDP 端口无关；若 8085 被占用需先释放，否则应用可能异常退出，导致无法连接 CDP。
这样，你的工具就能“自动检测接口”（CDP 端口与 Telegram 页），实时获取聊天记录并输出推荐回复。


精简版聊天记录抓取方案
创建独立脚本 tg-minimal-capture.js：
执行步骤
创建新文件 resources/app/client/src/preload/tg-minimal-capture.js
复制上述代码到文件中
运行脚本：
检查生成的 chat_records.json 文件
特点
完全无UI界面
单次执行，抓取后自动退出
输出格式化的JSON文件
只抓取当前可见消息（最多200条）
此方案满足您"最小化实现"和"生成文件查看内容"的需求，且避免了窗口显示问题。