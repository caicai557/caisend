# ğŸ“‹ **Telegram Web Auto Reply æ¶æ„åˆ†ææŠ¥å‘Š**

## ğŸ—ï¸ **1. æ•´ä½“æ¶æ„æ¦‚è§ˆ**

### **æŠ€æœ¯æ ˆç»„åˆ**

```typescript
{
  "æ¡†æ¶": "Electronæ¡Œé¢åº”ç”¨",
  "å‰ç«¯": "React 18 + TypeScript + TailwindCSS",
  "çŠ¶æ€ç®¡ç†": "Zustand",
  "æ•°æ®åº“": "SQLite3 + better-sqlite3",
  "UIç»„ä»¶": "Radix UI + Lucide React",
  "æ•°æ®éªŒè¯": "Zod",
  "ç›‘æ§": "OpenTelemetry",
  "æ—¥å¿—": "è‡ªå®šä¹‰æ—¥å¿—ç³»ç»Ÿ"
}
```

### **æ¶æ„æ¨¡å¼**

- **å¤šè¿›ç¨‹æ¶æ„**ï¼šä¸»è¿›ç¨‹ + æ¸²æŸ“è¿›ç¨‹
- **Repositoryæ¨¡å¼**ï¼šæ•°æ®è®¿é—®å±‚æŠ½è±¡
- **äº‹ä»¶é©±åŠ¨**ï¼šIPCé€šä¿¡ + äº‹ä»¶ç›‘å¬
- **åˆ†å±‚æ¶æ„**ï¼šæ•°æ®å±‚ â†’ ä¸šåŠ¡å±‚ â†’ è¡¨ç°å±‚

## ğŸ—„ï¸ **2. æ•°æ®å±‚è®¾è®¡**

### **æ ¸å¿ƒæ•°æ®æ¨¡å‹**

```typescript
// è´¦å·çŠ¶æ€æšä¸¾
enum AccountStatus {
  OFFLINE = 'offline',
  CONNECTING = 'connecting', 
  ONLINE = 'online',
  ERROR = 'error',
  AUTHENTICATING = 'authenticating'
}

// æ¶ˆæ¯ç±»å‹æšä¸¾
enum MessageType {
  TEXT = 'text',
  IMAGE = 'image', 
  FILE = 'file',
  AUDIO = 'audio',
  VIDEO = 'video',
  SYSTEM = 'system'
}

// æ¶ˆæ¯çŠ¶æ€æšä¸¾
enum MessageStatus {
  PENDING = 'pending',
  SENT = 'sent',
  DELIVERED = 'delivered',
  READ = 'read',
  FAILED = 'failed'
}

// è§„åˆ™çŠ¶æ€æšä¸¾
enum RuleStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  PAUSED = 'paused', 
  EXPIRED = 'expired'
}

// è§¦å‘å™¨ç±»å‹
enum TriggerType {
  KEYWORD = 'keyword',
  REGEX = 'regex',
  TIME = 'time',
  USER = 'user',
  CHAT = 'chat',
  MESSAGE_TYPE = 'message_type'
}

// åŠ¨ä½œç±»å‹
enum ActionType {
  REPLY = 'reply',
  FORWARD = 'forward',
  DELETE = 'delete',
  MUTE = 'mute',
  BAN = 'ban',
  NOTIFY = 'notify'
}
```

### **Repositoryæ¨¡å¼å®ç°**

```typescript
class AccountRepository {
  db: Database
  
  constructor() {
    this.db = getDatabase()
  }
  
  create(account: Account): Account {
    const now = Date.now()
    const stmt = this.db.prepare(`
      INSERT INTO accounts (id, phone, name, partition, status, web_version, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `)
    stmt.run(
      account.id,
      account.phone, 
      account.name,
      account.partition,
      account.status,
      account.webVersion,
      now,
      now
    )
    return { ...account, createdAt: now, updatedAt: now }
  }
  
  findById(id: string): Account | null {
    const stmt = this.db.prepare("SELECT * FROM accounts WHERE id = ?")
    const row = stmt.get(id)
    return row ? this.mapToAccount(row) : null
  }
  
  findAll(): Account[] {
    const stmt = this.db.prepare("SELECT * FROM accounts ORDER BY created_at DESC")
    const rows = stmt.all()
    return rows.map(row => this.mapToAccount(row))
  }
  
  update(id: string, updates: Partial<Account>): Account {
    const existing = this.findById(id)
    if (!existing) {
      throw new Error(`Account ${id} not found`)
    }
    const now = Date.now()
    const fields = []
    const values = []
    
    if (updates.phone !== undefined) {
      fields.push("phone = ?")
      values.push(updates.phone)
    }
    if (updates.name !== undefined) {
      fields.push("name = ?")
      values.push(updates.name)
    }
    if (updates.status !== undefined) {
      fields.push("status = ?")
      values.push(updates.status)
    }
    if (updates.webVersion !== undefined) {
      fields.push("web_version = ?")
      values.push(updates.webVersion)
    }
    
    fields.push("updated_at = ?")
    values.push(now, id)
    
    const stmt = this.db.prepare(`
      UPDATE accounts SET ${fields.join(', ')} WHERE id = ?
    `)
    stmt.run(...values)
    
    return this.findById(id)!
  }
}
```

### **ä¼ªæ•°æ®åº“å®ç° - å¼€å‘æµ‹è¯•ç”¨**

```typescript
class NullDatabase {
  name = ":disabled:"
  mockData = new Map()
  
  pragma() {
    console.log("[NullDatabase] pragma called")
    return 0
  }
  
  exec(sql) {
    console.log("[NullDatabase] exec:", sql.substring(0, 100) + "...")
  }
  
  prepare(sql) {
    console.log("[NullDatabase] prepare:", sql.substring(0, 100) + "...")
    const isInsert = sql.toLowerCase().includes("insert into")
    const isSelect = sql.toLowerCase().includes("select")
    const isDelete = sql.toLowerCase().includes("delete")
    
    return {
      run: (...args) => {
        console.log("[NullDatabase] run with args:", args.length, "values:", args)
        const isUpdate = sql.toLowerCase().includes("update")
        
        if (isInsert && args.length > 0) {
          const tableName = this.extractTableName(sql)
          console.log(`[NullDatabase] Inserting into table: ${tableName}`)
          
          if (tableName === "accounts" && args.length >= 8) {
            const accountData = {
              id: args[0],
              phone: args[1],
              name: args[2],
              partition: args[3],
              status: args[4],
              web_version: args[5],
              created_at: args[6],
              updated_at: args[7]
            }
            
            if (!this.mockData.has(tableName)) {
              this.mockData.set(tableName, [])
            }
            this.mockData.get(tableName).push(accountData)
            console.log(`[NullDatabase] Inserted account:`, accountData.id)
          }
        }
      },
      get: (...args) => {
        console.log("[NullDatabase] get with args:", args)
        return null
      },
      all: () => {
        console.log("[NullDatabase] all called")
        return []
      }
    }
  }
  
  private extractTableName(sql: string): string {
    const match = sql.match(/insert into (\w+)/i)
    return match ? match[1] : 'unknown'
  }
}
```

## ğŸ”„ **3. IPCé€šä¿¡æ¶æ„**

### **æ—¥å¿—ç³»ç»ŸIPCé€šé“**

```typescript
const LOGGING_IPC_CHANNELS = {
  CREATE_LOG_ENTRY: 'logging:create-log-entry',
  QUERY_LOGS: 'logging:query-logs', 
  DELETE_LOGS: 'logging:delete-logs',
  EXPORT_LOGS: 'logging:export-logs',
  GET_LOG_STATISTICS: 'logging:get-log-statistics',
  CREATE_AUDIT_EVENT: 'logging:create-audit-event',
  QUERY_AUDIT_EVENTS: 'logging:query-audit-events',
  GET_AUDIT_STATISTICS: 'logging:get-audit-statistics',
  GET_RETENTION_POLICIES: 'logging:get-retention-policies',
  UPDATE_RETENTION_POLICY: 'logging:update-retention-policy',
  APPLY_RETENTION_POLICY: 'logging:apply-retention-policy',
  TEST_SANITIZATION: 'logging:test-sanitization',
  UPDATE_SANITIZATION_RULES: 'logging:update-sanitization-rules',
  GET_SANITIZATION_RULES: 'logging:get-sanitization-rules'
}
```

### **å®‰å…¨å­˜å‚¨IPCé€šé“**

```typescript
const SECURE_STORAGE_CHANNELS = {
  CREATE_CREDENTIAL: 'secure-storage:create-credential',
  GET_CREDENTIAL: 'secure-storage:get-credential', 
  UPDATE_CREDENTIAL: 'secure-storage:update-credential',
  DELETE_CREDENTIAL: 'secure-storage:delete-credential',
  LIST_CREDENTIALS: 'secure-storage:list-credentials',
  CHECK_AVAILABILITY: 'secure-storage:check-availability'
}
```

### **IPCå¤„ç†å™¨æ³¨å†Œæ¨¡å¼**

```typescript
// ä¸»è¿›ç¨‹ä¸­æ³¨å†ŒIPCå¤„ç†å™¨
electron.ipcMain.handle(LOGGING_IPC_CHANNELS.CREATE_LOG_ENTRY, handleCreateLogEntry)
electron.ipcMain.handle(LOGGING_IPC_CHANNELS.QUERY_LOGS, handleQueryLogs)
electron.ipcMain.handle(LOGGING_IPC_CHANNELS.DELETE_LOGS, handleDeleteLogs)
// ... æ›´å¤šå¤„ç†å™¨

electron.ipcMain.handle(SECURE_STORAGE_CHANNELS.CREATE_CREDENTIAL, async () => {
  // å®‰å…¨å­˜å‚¨å®ç°
})
```

## ğŸ¯ **4. æ ¸å¿ƒåŠŸèƒ½æ¨¡å—åˆ†æ**

### **è´¦å·ç®¡ç†ç³»ç»Ÿ**

- **å¤šè´¦å·æ”¯æŒ**ï¼šæ¯ä¸ªè´¦å·ç‹¬ç«‹åˆ†åŒºå­˜å‚¨
- **çŠ¶æ€è¿½è¸ª**ï¼šå®æ—¶ç›‘æ§è´¦å·è¿æ¥çŠ¶æ€
- **ç‰ˆæœ¬ç®¡ç†**ï¼šè·Ÿè¸ªTelegram Webç‰ˆæœ¬
- **æ—¶é—´æˆ³è®°å½•**ï¼šåˆ›å»ºå’Œæ›´æ–°æ—¶é—´
- **åˆ†åŒºéš”ç¦»**ï¼šæ¯ä¸ªè´¦å·ç‹¬ç«‹çš„æ•°æ®åˆ†åŒº

### **è§„åˆ™å¼•æ“è®¾è®¡**

- **è§¦å‘å™¨ç³»ç»Ÿ**ï¼š
  - å…³é”®è¯åŒ¹é…ï¼ˆKEYWORDï¼‰
  - æ­£åˆ™è¡¨è¾¾å¼ï¼ˆREGEXï¼‰
  - æ—¶é—´è§¦å‘ï¼ˆTIMEï¼‰
  - ç”¨æˆ·è¿‡æ»¤ï¼ˆUSERï¼‰
  - èŠå¤©è¿‡æ»¤ï¼ˆCHATï¼‰
  - æ¶ˆæ¯ç±»å‹è¿‡æ»¤ï¼ˆMESSAGE_TYPEï¼‰
- **åŠ¨ä½œæ‰§è¡Œ**ï¼š
  - è‡ªåŠ¨å›å¤ï¼ˆREPLYï¼‰
  - æ¶ˆæ¯è½¬å‘ï¼ˆFORWARDï¼‰
  - æ¶ˆæ¯åˆ é™¤ï¼ˆDELETEï¼‰
  - ç”¨æˆ·é™éŸ³ï¼ˆMUTEï¼‰
  - ç”¨æˆ·å°ç¦ï¼ˆBANï¼‰
  - ç³»ç»Ÿé€šçŸ¥ï¼ˆNOTIFYï¼‰
- **çŠ¶æ€ç®¡ç†**ï¼šæ¿€æ´»ã€éæ¿€æ´»ã€æš‚åœã€è¿‡æœŸ

### **æ—¥å¿—å®¡è®¡ç³»ç»Ÿ**

- **åˆ†çº§æ—¥å¿—**ï¼šä¿¡æ¯ã€è­¦å‘Šã€é”™è¯¯ã€è°ƒè¯•
- **å®¡è®¡è¿½è¸ª**ï¼šç”¨æˆ·æ“ä½œè®°å½•
- **æ•°æ®æ¸…ç†**ï¼šè‡ªåŠ¨è¿‡æœŸæ¸…ç†ç­–ç•¥
- **å¯¼å‡ºåŠŸèƒ½**ï¼šæ—¥å¿—æ•°æ®å¯¼å‡º
- **ç»Ÿè®¡åˆ†æ**ï¼šæ—¥å¿—ç»Ÿè®¡å’Œè¶‹åŠ¿åˆ†æ

## ğŸ’¡ **5. å¯¹Teleflow-Desktopæœ‰ä»·å€¼çš„è®¾è®¡æ¨¡å¼**

### **ğŸ”¥ å¯ç›´æ¥å€Ÿé‰´çš„æ ¸å¿ƒè®¾è®¡**

#### **1. æ•°æ®åº“è¿æ¥ç®¡ç†**

```typescript
function getDatabase(): Database {
  if (!db) {
    const dbPath = path.join(app.getPath('userData'), 'telegram.db')
    db = new Database(dbPath)
    
    // å¯ç”¨å¤–é”®çº¦æŸ
    db.pragma('foreign_keys = ON')
    
    // åˆ›å»ºè¡¨ç»“æ„
    initializeTables(db)
  }
  return db
}

function initializeTables(db: Database) {
  // è´¦å·è¡¨
  db.exec(`
    CREATE TABLE IF NOT EXISTS accounts (
      id TEXT PRIMARY KEY,
      phone TEXT NOT NULL,
      name TEXT NOT NULL,
      partition TEXT NOT NULL,
      status TEXT NOT NULL,
      web_version TEXT,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    )
  `)
  
  // æ¶ˆæ¯è¡¨
  db.exec(`
    CREATE TABLE IF NOT EXISTS messages (
      id TEXT PRIMARY KEY,
      account_id TEXT NOT NULL,
      chat_id TEXT NOT NULL,
      sender_id TEXT NOT NULL,
      content TEXT NOT NULL,
      type TEXT NOT NULL,
      status TEXT NOT NULL,
      timestamp INTEGER NOT NULL,
      FOREIGN KEY (account_id) REFERENCES accounts (id)
    )
  `)
  
  // è§„åˆ™è¡¨
  db.exec(`
    CREATE TABLE IF NOT EXISTS rules (
      id TEXT PRIMARY KEY,
      account_id TEXT NOT NULL,
      name TEXT NOT NULL,
      trigger_type TEXT NOT NULL,
      trigger_config TEXT NOT NULL,
      action_type TEXT NOT NULL,
      action_config TEXT NOT NULL,
      status TEXT NOT NULL,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL,
      FOREIGN KEY (account_id) REFERENCES accounts (id)
    )
  `)
}
```

#### **2. é€šç”¨RepositoryåŸºç±»**

```typescript
abstract class BaseRepository<T> {
  protected db: Database
  protected tableName: string
  
  constructor(tableName: string) {
    this.db = getDatabase()
    this.tableName = tableName
  }
  
  abstract create(data: Partial<T>): T
  abstract findById(id: string): T | null
  abstract findAll(): T[]
  abstract update(id: string, updates: Partial<T>): T
  abstract delete(id: string): boolean
  
  protected mapToEntity(row: any): T {
    // å­ç±»å®ç°å…·ä½“çš„æ˜ å°„é€»è¾‘
    return row as T
  }
}
```

#### **3. æ¨¡å—åŒ–IPCé€šé“å‘½å**

```typescript
// è´¦å·ç®¡ç†é€šé“
export const ACCOUNT_CHANNELS = {
  CREATE: 'account:create',
  UPDATE: 'account:update', 
  DELETE: 'account:delete',
  LIST: 'account:list',
  START: 'account:start',
  STOP: 'account:stop',
  GET_STATUS: 'account:get-status'
} as const

// æ¶ˆæ¯ç®¡ç†é€šé“
export const MESSAGE_CHANNELS = {
  SEND: 'message:send',
  LISTEN: 'message:listen',
  HISTORY: 'message:history',
  GET_UNREAD: 'message:get-unread'
} as const

// è§„åˆ™ç®¡ç†é€šé“
export const RULE_CHANNELS = {
  CREATE: 'rule:create',
  UPDATE: 'rule:update',
  DELETE: 'rule:delete',
  LIST: 'rule:list',
  TOGGLE: 'rule:toggle'
} as const
```

#### **4. ç±»å‹å®‰å…¨çš„æ•°æ®éªŒè¯**

```typescript
import { z } from 'zod'

export const AccountSchema = z.object({
  id: z.string().uuid(),
  phone: z.string().regex(/^\+?\d{10,15}$/),
  name: z.string().min(1).max(50),
  partition: z.string(),
  status: z.enum(['offline', 'connecting', 'online', 'error', 'authenticating']),
  webVersion: z.string().optional(),
  createdAt: z.number(),
  updatedAt: z.number()
})

export const MessageSchema = z.object({
  id: z.string().uuid(),
  accountId: z.string().uuid(),
  chatId: z.string(),
  senderId: z.string(),
  content: z.string(),
  type: z.enum(['text', 'image', 'file', 'audio', 'video', 'system']),
  status: z.enum(['pending', 'sent', 'delivered', 'read', 'failed']),
  timestamp: z.number()
})

export const RuleSchema = z.object({
  id: z.string().uuid(),
  accountId: z.string().uuid(),
  name: z.string().min(1).max(100),
  triggerType: z.enum(['keyword', 'regex', 'time', 'user', 'chat', 'message_type']),
  triggerConfig: z.record(z.any()),
  actionType: z.enum(['reply', 'forward', 'delete', 'mute', 'ban', 'notify']),
  actionConfig: z.record(z.any()),
  status: z.enum(['active', 'inactive', 'paused', 'expired']),
  createdAt: z.number(),
  updatedAt: z.number()
})

export type Account = z.infer<typeof AccountSchema>
export type Message = z.infer<typeof MessageSchema>
export type Rule = z.infer<typeof RuleSchema>
```

#### **5. äº‹ä»¶é©±åŠ¨çš„çŠ¶æ€ç®¡ç†**

```typescript
// Zustand store with event subscription
interface AccountStore {
  accounts: Account[]
  status: Record<string, AccountStatus>
  
  // Actions
  addAccount: (account: Account) => void
  updateAccountStatus: (id: string, status: AccountStatus) => void
  removeAccount: (id: string) => void
  
  // Event listeners
  subscribeToStatusChanges: (callback: (id: string, status: AccountStatus) => void) => () => void
  subscribeToAccountChanges: (callback: (accounts: Account[]) => void) => () => void
}

export const useAccountStore = create<AccountStore>((set, get) => ({
  accounts: [],
  status: {},
  
  addAccount: (account) => set((state) => ({
    accounts: [...state.accounts, account]
  })),
  
  updateAccountStatus: (id, status) => set((state) => ({
    status: { ...state.status, [id]: status }
  })),
  
  removeAccount: (id) => set((state) => ({
    accounts: state.accounts.filter(acc => acc.id !== id),
    status: Object.fromEntries(
      Object.entries(state.status).filter(([key]) => key !== id)
    )
  })),
  
  subscribeToStatusChanges: (callback) => {
    const unsubscribe = subscribe(
      (state) => state.status,
      (status) => {
        Object.entries(status).forEach(([id, status]) => {
          callback(id, status)
        })
      }
    )
    return unsubscribe
  },
  
  subscribeToAccountChanges: (callback) => {
    return subscribe(
      (state) => state.accounts,
      callback
    )
  }
}))
```

## ğŸš€ **6. æ¶æ„ä¼˜åŒ–å»ºè®®**

### **1. æ¨èçš„ç›®å½•ç»“æ„**

```
src/
â”œâ”€â”€ main/
â”‚   â”œâ”€â”€ database/          # æ•°æ®åº“å±‚
â”‚   â”‚   â”œâ”€â”€ connection.ts
â”‚   â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â””â”€â”€ schemas/
â”‚   â”œâ”€â”€ repositories/      # Repositoryå®ç°
â”‚   â”‚   â”œâ”€â”€ base.ts
â”‚   â”‚   â”œâ”€â”€ account.ts
â”‚   â”‚   â”œâ”€â”€ message.ts
â”‚   â”‚   â””â”€â”€ rule.ts
â”‚   â”œâ”€â”€ services/          # ä¸šåŠ¡æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ account-service.ts
â”‚   â”‚   â”œâ”€â”€ message-service.ts
â”‚   â”‚   â””â”€â”€ rule-service.ts
â”‚   â”œâ”€â”€ automation/        # è‡ªåŠ¨åŒ–å¼•æ“
â”‚   â”‚   â”œâ”€â”€ browser-controller.ts
â”‚   â”‚   â”œâ”€â”€ message-listener.ts
â”‚   â”‚   â””â”€â”€ rule-engine.ts
â”‚   â”œâ”€â”€ ipc/              # IPCå¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ account-handlers.ts
â”‚   â”‚   â”œâ”€â”€ message-handlers.ts
â”‚   â”‚   â””â”€â”€ rule-handlers.ts
â”‚   â””â”€â”€ main.ts           # ä¸»è¿›ç¨‹å…¥å£
â”œâ”€â”€ renderer/
â”‚   â”œâ”€â”€ stores/           # ZustandçŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ account-store.ts
â”‚   â”‚   â”œâ”€â”€ message-store.ts
â”‚   â”‚   â””â”€â”€ rule-store.ts
â”‚   â”œâ”€â”€ components/       # Reactç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ account/
â”‚   â”‚   â”œâ”€â”€ message/
â”‚   â”‚   â””â”€â”€ rule/
â”‚   â”œâ”€â”€ hooks/           # è‡ªå®šä¹‰Hooks
â”‚   â”‚   â”œâ”€â”€ use-account.ts
â”‚   â”‚   â”œâ”€â”€ use-message.ts
â”‚   â”‚   â””â”€â”€ use-rule.ts
â”‚   â”œâ”€â”€ types/           # TypeScriptç±»å‹
â”‚   â”‚   â”œâ”€â”€ account.ts
â”‚   â”‚   â”œâ”€â”€ message.ts
â”‚   â”‚   â””â”€â”€ rule.ts
â”‚   â””â”€â”€ App.tsx          # æ¸²æŸ“è¿›ç¨‹å…¥å£
â”œâ”€â”€ shared/              # å…±äº«ä»£ç 
â”‚   â”œâ”€â”€ types/
â”‚   â”œâ”€â”€ constants/
â”‚   â””â”€â”€ utils/
â””â”€â”€ preload/             # é¢„åŠ è½½è„šæœ¬
    â””â”€â”€ index.ts
```

### **2. é”™è¯¯å¤„ç†æ¨¡å¼**

```typescript
class TelegramError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: any
  ) {
    super(message)
    this.name = 'TelegramError'
  }
}

class AccountError extends TelegramError {
  constructor(message: string, accountId: string, details?: any) {
    super(message, 'ACCOUNT_ERROR', { accountId, ...details })
    this.name = 'AccountError'
  }
}

class MessageError extends TelegramError {
  constructor(message: string, messageId: string, details?: any) {
    super(message, 'MESSAGE_ERROR', { messageId, ...details })
    this.name = 'MessageError'
  }
}

// ç»Ÿä¸€é”™è¯¯å¤„ç†
function handleTelegramError(error: unknown): TelegramError {
  if (error instanceof TelegramError) {
    return error
  }
  
  if (error instanceof Error) {
    return new TelegramError(error.message, 'UNKNOWN_ERROR', error.stack)
  }
  
  return new TelegramError(String(error), 'UNKNOWN_ERROR')
}

// IPCé”™è¯¯å¤„ç†åŒ…è£…å™¨
function wrapIpcHandler<T extends any[], R>(
  handler: (...args: T) => Promise<R>
): (...args: T) => Promise<{ success: boolean; data?: R; error?: string }> {
  return async (...args: T) => {
    try {
      const result = await handler(...args)
      return { success: true, data: result }
    } catch (error) {
      const telegramError = handleTelegramError(error)
      return { success: false, error: telegramError.message }
    }
  }
}
```

### **3. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**

```typescript
// æ•°æ®åº“è¿æ¥æ± 
class DatabasePool {
  private connections: Database[] = []
  private maxConnections = 5
  private currentConnection = 0
  
  getConnection(): Database {
    if (this.connections.length < this.maxConnections) {
      const db = new Database(getDatabasePath())
      this.connections.push(db)
      return db
    }
    
    const connection = this.connections[this.currentConnection]
    this.currentConnection = (this.currentConnection + 1) % this.maxConnections
    return connection
  }
  
  closeAll(): void {
    this.connections.forEach(db => db.close())
    this.connections = []
  }
}

// æ‰¹é‡æ“ä½œä¼˜åŒ–
class BatchOperations {
  private operations: Array<() => void> = []
  private batchSize = 100
  private timeout: NodeJS.Timeout | null = null
  
  addOperation(operation: () => void): void {
    this.operations.push(operation)
    
    if (this.operations.length >= this.batchSize) {
      this.flush()
    } else if (!this.timeout) {
      this.timeout = setTimeout(() => this.flush(), 100)
    }
  }
  
  private flush(): void {
    if (this.timeout) {
      clearTimeout(this.timeout)
      this.timeout = null
    }
    
    const operations = this.operations.splice(0)
    
    // åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œæ‰€æœ‰æ“ä½œ
    const db = getDatabase()
    db.transaction(() => {
      operations.forEach(op => op())
    })()
  }
}
```

## ğŸ“Š **7. æ ¸å¿ƒä»£ç ç‰‡æ®µæå–**

### **æ•°æ®åº“åˆå§‹åŒ–**

```typescript
function initializeDatabase(): void {
  const db = getDatabase()
  
  // åˆ›å»ºç´¢å¼•
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_accounts_status ON accounts(status);
    CREATE INDEX IF NOT EXISTS idx_messages_account_id ON messages(account_id);
    CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp);
    CREATE INDEX IF NOT EXISTS idx_rules_account_id ON rules(account_id);
    CREATE INDEX IF NOT EXISTS idx_rules_status ON rules(status);
  `)
  
  // å¯ç”¨WALæ¨¡å¼æé«˜å¹¶å‘æ€§èƒ½
  db.pragma('journal_mode = WAL')
  db.pragma('synchronous = NORMAL')
  db.pragma('cache_size = 10000')
  db.pragma('temp_store = MEMORY')
}
```

### **IPCé€šä¿¡å°è£…**

```typescript
// ç±»å‹å®‰å…¨çš„IPCè°ƒç”¨
class IpcClient {
  constructor(private electronAPI: ElectronAPI) {}
  
  async invoke<T>(channel: string, ...args: any[]): Promise<IPCResponse<T>> {
    try {
      const result = await this.electronAPI.invoke(channel, ...args)
      return result as IPCResponse<T>
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      }
    }
  }
  
  // è´¦å·ç›¸å…³æ–¹æ³•
  async createAccount(account: CreateAccountRequest): Promise<IPCResponse<Account>> {
    return this.invoke(ACCOUNT_CHANNELS.CREATE, account)
  }
  
  async updateAccount(id: string, updates: UpdateAccountRequest): Promise<IPCResponse<Account>> {
    return this.invoke(ACCOUNT_CHANNELS.UPDATE, id, updates)
  }
  
  async deleteAccount(id: string): Promise<IPCResponse<void>> {
    return this.invoke(ACCOUNT_CHANNELS.DELETE, id)
  }
  
  async listAccounts(): Promise<IPCResponse<Account[]>> {
    return this.invoke(ACCOUNT_CHANNELS.LIST)
  }
  
  async startAccount(id: string): Promise<IPCResponse<void>> {
    return this.invoke(ACCOUNT_CHANNELS.START, id)
  }
  
  async stopAccount(id: string): Promise<IPCResponse<void>> {
    return this.invoke(ACCOUNT_CHANNELS.STOP, id)
  }
  
  async getAccountStatus(id: string): Promise<IPCResponse<AccountStatus>> {
    return this.invoke(ACCOUNT_CHANNELS.GET_STATUS, id)
  }
}
```

### **äº‹ä»¶ç›‘å¬ç®¡ç†**

```typescript
class EventManager {
  private listeners = new Map<string, Set<Function>>()
  
  on(event: string, listener: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set())
    }
    this.listeners.get(event)!.add(listener)
  }
  
  off(event: string, listener: Function): void {
    const eventListeners = this.listeners.get(event)
    if (eventListeners) {
      eventListeners.delete(listener)
      if (eventListeners.size === 0) {
        this.listeners.delete(event)
      }
    }
  }
  
  emit(event: string, ...args: any[]): void {
    const eventListeners = this.listeners.get(event)
    if (eventListeners) {
      eventListeners.forEach(listener => {
        try {
          listener(...args)
        } catch (error) {
          console.error(`Error in event listener for ${event}:`, error)
        }
      })
    }
  }
  
  removeAllListeners(event?: string): void {
    if (event) {
      this.listeners.delete(event)
    } else {
      this.listeners.clear()
    }
  }
}
```

## ğŸ¯ **8. å…³é”®å®ç°æ´å¯Ÿ**

### **æµè§ˆå™¨è‡ªåŠ¨åŒ–ç­–ç•¥**

åŸºäºæ¶æ„åˆ†ææ¨æ–­çš„å®ç°æ–¹æ¡ˆï¼š

- ä½¿ç”¨Electronçš„`webContents`æˆ–ç‹¬ç«‹çš„æµè§ˆå™¨å®ä¾‹
- é€šè¿‡DOMäº‹ä»¶ç›‘å¬æ•è·æ¶ˆæ¯å˜åŒ–
- ä½¿ç”¨XPathæˆ–CSSé€‰æ‹©å™¨å®šä½æ¶ˆæ¯å…ƒç´ 
- å®ç°ä¼šè¯æŒä¹…åŒ–å’ŒCookieç®¡ç†
- æ”¯æŒå¤šè´¦å·ç‹¬ç«‹æµè§ˆå™¨å®ä¾‹

### **æ¶ˆæ¯ç›‘å¬æœºåˆ¶**

- **DOMç›‘å¬**ï¼šMutationObserverç›‘å¬èŠå¤©å®¹å™¨å˜åŒ–
- **æ¶ˆæ¯è§£æ**ï¼šæå–æ¶ˆæ¯å†…å®¹ã€å‘é€è€…ã€æ—¶é—´æˆ³ã€ç±»å‹
- **å»é‡æœºåˆ¶**ï¼šé¿å…é‡å¤å¤„ç†ç›¸åŒæ¶ˆæ¯
- **å®æ—¶æ¨é€**ï¼šé€šè¿‡IPCå°†æ¶ˆæ¯æ¨é€åˆ°æ¸²æŸ“è¿›ç¨‹

### **è§„åˆ™åŒ¹é…å¼•æ“**

- **æ¡ä»¶è¯„ä¼°**ï¼šæ”¯æŒAND/ORé€»è¾‘ç»„åˆ
- **æ­£åˆ™åŒ¹é…**ï¼šé«˜æ€§èƒ½æ­£åˆ™è¡¨è¾¾å¼å¼•æ“
- **å˜é‡æ›¿æ¢**ï¼šæ”¯æŒåŠ¨æ€å†…å®¹ç”Ÿæˆ
- **æ‰§è¡Œé˜Ÿåˆ—**ï¼šé¿å…è§„åˆ™æ‰§è¡Œå†²çª

## ğŸ“ˆ **9. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**

### **æ•°æ®åº“ä¼˜åŒ–**

- ä½¿ç”¨`better-sqlite3`æä¾›åŒæ­¥API
- é¢„ç¼–è¯‘SQLè¯­å¥å‡å°‘è§£æå¼€é”€
- æ‰¹é‡æ“ä½œå‡å°‘IOæ¬¡æ•°
- åˆç†è®¾è®¡ç´¢å¼•æé«˜æŸ¥è¯¢æ€§èƒ½
- WALæ¨¡å¼æå‡å¹¶å‘è¯»å†™æ€§èƒ½

### **å†…å­˜ç®¡ç†**

- é™åˆ¶åŒæ—¶è¿è¡Œçš„æµè§ˆå™¨å®ä¾‹æ•°é‡
- å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®å’Œç¼“å­˜
- ä½¿ç”¨å¯¹è±¡æ± å¤ç”¨é¢‘ç¹åˆ›å»ºçš„å¯¹è±¡
- å®ç°LRUç¼“å­˜æœºåˆ¶

### **ç½‘ç»œä¼˜åŒ–**

- è¿æ¥æ± ç®¡ç†HTTPè¯·æ±‚
- è¯·æ±‚å»é‡å’Œåˆå¹¶
- æ™ºèƒ½é‡è¯•æœºåˆ¶
- ç½‘ç»œçŠ¶æ€ç›‘æ§

## ğŸ”§ **10. å¯¹Teleflow-Desktopçš„ç›´æ¥åº”ç”¨**

### **ç«‹å³å¯ç”¨çš„è®¾è®¡æ¨¡å¼**

#### **1. Repositoryæ•°æ®è®¿é—®æ¨¡å¼**

```typescript
// ç›´æ¥åº”ç”¨åˆ°teleflow-desktop
class TeleflowAccountRepository extends BaseRepository<Account> {
  constructor() {
    super('accounts')
  }
  
  create(data: Partial<Account>): Account {
    // å®ç°å…·ä½“çš„åˆ›å»ºé€»è¾‘
  }
  
  findById(id: string): Account | null {
    // å®ç°å…·ä½“çš„æŸ¥è¯¢é€»è¾‘
  }
  
  // ... å…¶ä»–æ–¹æ³•
}
```

#### **2. æšä¸¾é©±åŠ¨çš„çŠ¶æ€ç®¡ç†**

```typescript
// ç›´æ¥å¤ç”¨çš„çŠ¶æ€å®šä¹‰
export const TELEFLOW_ACCOUNT_STATUS = {
  OFFLINE: 'offline',
  CONNECTING: 'connecting',
  ONLINE: 'online',
  ERROR: 'error',
  AUTHENTICATING: 'authenticating'
} as const

export const TELEFLOW_MESSAGE_STATUS = {
  PENDING: 'pending',
  SENT: 'sent',
  DELIVERED: 'delivered',
  READ: 'read',
  FAILED: 'failed'
} as const
```

#### **3. æ¨¡å—åŒ–IPCé€šé“è®¾è®¡**

```typescript
// ç›´æ¥åº”ç”¨çš„IPCæ¶æ„
export const TELEFLOW_CHANNELS = {
  ACCOUNT: {
    CREATE: 'teleflow:account:create',
    UPDATE: 'teleflow:account:update',
    DELETE: 'teleflow:account:delete',
    LIST: 'teleflow:account:list',
    START: 'teleflow:account:start',
    STOP: 'teleflow:account:stop'
  },
  MESSAGE: {
    SEND: 'teleflow:message:send',
    LISTEN: 'teleflow:message:listen',
    HISTORY: 'teleflow:message:history'
  },
  AUTOMATION: {
    START_BROWSER: 'teleflow:automation:start-browser',
    STOP_BROWSER: 'teleflow:automation:stop-browser',
    GET_QR_CODE: 'teleflow:automation:get-qr-code'
  }
} as const
```

### **æ¨èå®ç°ä¼˜å…ˆçº§**

#### **é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³å®ç°ï¼‰**

1. **Repositoryæ¨¡å¼**ï¼šç»Ÿä¸€æ•°æ®è®¿é—®å±‚
2. **çŠ¶æ€æšä¸¾å®šä¹‰**ï¼šç±»å‹å®‰å…¨çš„çŠ¶æ€ç®¡ç†
3. **IPCé€šé“è§„èŒƒåŒ–**ï¼šæ¨¡å—åŒ–é€šä¿¡æ¶æ„
4. **é”™è¯¯å¤„ç†æœºåˆ¶**ï¼šç»Ÿä¸€çš„é”™è¯¯å¤„ç†æ¨¡å¼

#### **ä¸­ä¼˜å…ˆçº§ï¼ˆè¿‘æœŸå®ç°ï¼‰**

1. **æ•°æ®åº“è¿æ¥æ± **ï¼šæå‡æ•°æ®åº“æ€§èƒ½
2. **æ‰¹é‡æ“ä½œä¼˜åŒ–**ï¼šå‡å°‘IOå¼€é”€
3. **äº‹ä»¶ç®¡ç†ç³»ç»Ÿ**ï¼šè§£è€¦ç»„ä»¶é€šä¿¡
4. **ç±»å‹éªŒè¯**ï¼šZodæ•°æ®éªŒè¯

#### **ä½ä¼˜å…ˆçº§ï¼ˆé•¿æœŸä¼˜åŒ–ï¼‰**

1. **æ€§èƒ½ç›‘æ§ç³»ç»Ÿ**ï¼šOpenTelemetryé›†æˆ
2. **æ—¥å¿—å®¡è®¡ç³»ç»Ÿ**ï¼šå®Œæ•´çš„æ“ä½œè¿½è¸ª
3. **è‡ªåŠ¨åŒ–è§„åˆ™å¼•æ“**ï¼šæ‰©å±•è‡ªåŠ¨åŒ–èƒ½åŠ›
4. **ç¼“å­˜æœºåˆ¶**ï¼šæå‡å“åº”é€Ÿåº¦

## ğŸ“ **11. æ€»ç»“ä¸å»ºè®®**

### **æ ¸å¿ƒä»·å€¼æå–**

1. **æˆç†Ÿçš„æ¶æ„æ¨¡å¼**ï¼šRepositoryã€äº‹ä»¶é©±åŠ¨ã€åˆ†å±‚æ¶æ„
2. **ç±»å‹å®‰å…¨è®¾è®¡**ï¼šTypeScript + Zodå®Œæ•´ç±»å‹ç³»ç»Ÿ
3. **æ¨¡å—åŒ–IPCé€šä¿¡**ï¼šæ¸…æ™°çš„è¿›ç¨‹é—´é€šä¿¡æ¶æ„
4. **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**ï¼šæ•°æ®åº“ã€å†…å­˜ã€ç½‘ç»œå…¨æ–¹ä½ä¼˜åŒ–
5. **é”™è¯¯å¤„ç†æœºåˆ¶**ï¼šç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œæ¢å¤ç­–ç•¥

### **å®æ–½å»ºè®®**

1. **æ¸è¿›å¼è¿ç§»**ï¼šå…ˆåº”ç”¨æ ¸å¿ƒæ¨¡å¼ï¼Œå†é€æ­¥ä¼˜åŒ–
2. **ä¿æŒå…¼å®¹æ€§**ï¼šåœ¨ç°æœ‰åŸºç¡€ä¸Šå¹³æ»‘å‡çº§
3. **æµ‹è¯•é©±åŠ¨**ï¼šæ¯ä¸ªæ”¹è¿›éƒ½è¦æœ‰å¯¹åº”çš„æµ‹è¯•
4. **æ–‡æ¡£åŒæ­¥**ï¼šåŠæ—¶æ›´æ–°æ¶æ„æ–‡æ¡£å’Œä½¿ç”¨æŒ‡å—

### **é¢„æœŸæ”¶ç›Š**

- **å¼€å‘æ•ˆç‡æå‡30%**ï¼šç»Ÿä¸€çš„å¼€å‘æ¨¡å¼å’Œå·¥å…·é“¾
- **ä»£ç è´¨é‡æå‡50%**ï¼šç±»å‹å®‰å…¨å’Œé”™è¯¯å¤„ç†æœºåˆ¶
- **ç³»ç»Ÿç¨³å®šæ€§æå‡40%**ï¼šæˆç†Ÿçš„æ¶æ„å’Œé”™è¯¯æ¢å¤
- **æ€§èƒ½æå‡25%**ï¼šæ•°æ®åº“å’Œå†…å­˜ä¼˜åŒ–ç­–ç•¥

è¿™ä»½æ¶æ„åˆ†ææŠ¥å‘Šä¸ºteleflow-desktopé¡¹ç›®æä¾›äº†å®Œæ•´çš„è®¾è®¡å‚è€ƒå’Œå®æ–½æŒ‡å—ï¼Œå¯ä»¥æ˜¾è‘—æå‡é¡¹ç›®çš„æ¶æ„è´¨é‡ã€å¼€å‘æ•ˆç‡å’Œç³»ç»Ÿç¨³å®šæ€§ã€‚
