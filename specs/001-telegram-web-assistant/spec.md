# 功能规格说明书：Telegram Web 助手

**功能分支**: `001-telegram-web-assistant`  
**创建日期**: 2025-01-16  
**状态**: 已澄清  
**最后更新**: 2025-01-16（精简 MVP 范围，移除多节点流程，添加非功能需求）  
**用户需求**: 在 Windows 上运行的 Telegram Web 助手，通过 CLI 提供**单账号 + 单聊天**的自动化管理，实现**自动已读**和基于**单节点关键词规则的自动回复**（含延时抖动），不使用 Telegram 官方 API，仅通过 Web 页面自动化实现。扩展功能（桌面 UI、多账号、群组、OCR）为 v1.1+ 版本规划

---

## 项目目标与非目标

### MVP 目标（v1.0）

本项目 MVP 旨在验证核心自动化价值，提供**单账号 + 单聊天**的命令行自动化管理：

1. **单账号管理**：支持配置**一个** Telegram 账号，通过 CLI 启动运行
2. **单聊天监控**：监控**一个**私聊对象的新消息（通过用户名或聊天名称指定）
3. **自动已读**：对新消息自动标记为已读，保持账号活跃状态
4. **单节点关键词自动回复**：基于字面量关键词 + 通配符（`*`、`?`）匹配规则，自动回复预设文本（单条规则命中 → 延时 → 回复）
5. **延时抖动**：支持固定延时 + 随机延时（0 到配置上限），模拟真人响应行为
6. **YAML 配置驱动**：所有行为通过 YAML 配置文件定义，无需修改代码即可调整规则
7. **命令行界面**：提供 `teleflow run --account <name> --config <path>` 等 CLI 命令

### 扩展功能目标（v1.1+）

MVP 稳定后，按以下优先级逐步扩展：

- **v1.1**：多账号独立运行、群组自动加入与欢迎消息、日志系统完善
- **v1.2**：OCR 数字识别（验证码、订单号）、桌面端 UI 基础版（只读监控）
- **v1.3+**：桌面端 UI 完整版（配置编辑）、正则表达式支持、高级匹配条件
- **v2.0**：多节点流程引擎（仅在用户明确需求时实现）

### 非目标

本项目**不会**实现以下功能：

- ❌ 不使用 Telegram 官方 Bot API 或 User API（仅通过 Web 自动化）
- ❌ 不支持复杂的图像识别（仅支持清晰截图中的数字识别）
- ❌ 不处理语音、视频等多媒体内容的自动回复
- ❌ 不提供云端托管或 SaaS 服务（仅本地运行）
- ❌ 不支持跨平台（仅支持 Windows）

---

## 澄清记录

### 会话 2025-01-16

#### 账号与配置模块

- **Q: 配置文件格式选择（JSON vs YAML）？** → A: 采用 YAML 格式，支持注释便于用户理解配置，依赖 pyyaml 库
- **Q: 浏览器数据目录路径如何组织？** → A: 默认使用相对路径 `./browser_data/{account_name}/`，配置中允许覆盖为绝对路径
- **Q: 聊天对象标识优先级（用户名 vs 数字 ID）？** → A: 优先使用 Telegram 用户名（@username）或聊天名称，数字 ID 作为高级可选字段

#### 自动已读模块

- **Q: 消息检测机制（DOM 监听 vs 定时轮询）？** → A: 采用定时轮询方式，间隔 2-3 秒
- **Q: 已读标记时机（立即 vs 等待加载）？** → A: 等待必要元素加载后标记，使用 Playwright `wait_for_selector`，超时记录日志

#### 关键词匹配与延时策略

- **Q: 关键词匹配模式范围？** → A: MVP 采用字面量关键词 + 少量通配符（`*`、`?`），数据结构预留 `use_regex` 字段供后续扩展
- **Q: 是否区分大小写？** → A: 默认不区分大小写，支持在单条规则中配置 `case_sensitive` 字段
- **Q: 随机延时的随机种子策略？** → A: 正常运行使用系统真随机数，调试模式支持配置 `random_seed` 参数
- **Q: 多条规则匹配时的处理？** → A: 记录所有匹配的规则到日志（WARNING 级别），仅执行第一条匹配的规则

#### 线性流程模块

- **Q: 多节点流程的状态持久化方式？** → A: MVP 采用内存状态，接口设计预留持久化钩子
- **Q: 节点跳转是否检测循环？** → A: 启动时校验配置，使用有向图环检测算法，发现循环则报错拒绝启动

#### 群组与邀请链接模块

- **Q: 群组加入失败的重试策略？** → A: 网络错误重试 3 次，其他失败（链接失效、已加入）直接跳过并记录日志
- **Q: 欢迎消息的发送时机？** → A: 等待 3-5 秒后发送，确保页面稳定
- **Q: 群组消息的监控范围？** → A: 默认监控所有群组消息，通过规则配置控制回复范围

#### 截图数字识别模块

- **Q: OCR 引擎选择？** → A: 使用 Tesseract OCR（通过 pytesseract），配置为数字识别模式
- **Q: 图片预处理策略？** → A: 进行极简预处理（灰度化 + 简单二值化），提高识别成功率
- **Q: OCR 结果是否缓存？** → A: MVP 不缓存，保持实现简单

#### 日志与运行方式模块

- **Q: 日志输出目标？** → A: 同时输出到控制台和文件，使用 Python logging 双 handler
- **Q: 日志文件轮转策略？** → A: 按天轮转，使用 `TimedRotatingFileHandler`
- **Q: 多账号运行的进程管理方式？** → A: 采用一账号一进程模式，CLI 命令形式 `teleflow run --account <name>`
- **Q: 命令行参数与配置文件的优先级？** → A: 命令行参数优先级高于配置文件，但仅覆盖少数字段（如 `--debug`、`--show-browser`、`--config-path`）
- **Q: 异常退出后的状态恢复策略？** → A: MVP 阶段重启后从当前时间开始监控，不做消息级状态持久化

---

## 用户场景与测试

### 用户故事 0a - 桌面端基础监控 UI（优先级: P2，v1.2 扩展功能）

**⚠️ 注意**：此功能属于 **v1.2 扩展**，**不属于 MVP（v1.0）范围**。MVP 仅提供命令行界面（CLI）。

**场景描述**：

用户希望通过简单的图形界面查看账号运行状态和日志，无需手动打开日志文件。基础监控 UI 提供：

1. **账号状态查看**：只读展示所有账号的运行状态（运行中/已停止）
2. **日志实时查看**：实时展示选中账号的最近日志（最近 100 条）
3. **基础过滤功能**：按账号、关键字、日志级别筛选日志

**为何 P2（v1.2）**：基础监控 UI 提升用户体验，但不影响核心功能。MVP（v1.0）通过 CLI 和日志文件已可完成所有操作，UI 属于易用性增强。

---

### 用户故事 0b - 桌面端高级管理 UI（优先级: P3，v1.3+ 扩展功能）

**⚠️ 注意**：此功能属于 **v1.3+ 扩展**，依赖 US0a（基础监控 UI）完成后实施。

**场景描述**：

用户希望通过图形界面完整管理所有账号和配置，无需手动编辑配置文件。高级管理 UI 在基础监控 UI 之上增加：

1. **配置编辑**：通过图形界面添加/编辑聊天对象、关键词规则、群组链接等
2. **账号控制**：一键启动/停止单个账号的后台进程
3. **账号管理**：新增/删除账号，编辑账号基本信息

**为何 P3（v1.3+）**：高级管理 UI 是完整的可视化管理界面，但需要更复杂的进程管理和配置同步机制。在 v1.1-v1.2 功能稳定后再实现，避免过早引入复杂度。

**独立测试**：

1. 打开桌面程序，验证界面正常加载（账号列表、配置面板、日志区域）
2. 点击"新增账号"，填写账号名称，验证账号添加成功
3. 选中一个账号，点击"启动"，验证后台进程启动且状态更新为"运行中"
4. 在配置面板中添加一条关键词规则，保存后验证配置写入成功
5. 点击"停止"，验证后台进程停止且状态更新为"已停止"

**验收场景**：

1. **Given** 用户首次打开桌面程序，**When** 界面加载完成，**Then** 显示空的账号列表和提示"点击'新增账号'开始"
2. **Given** 用户点击"新增账号"并填写账号名称"TestAccount"，**When** 点击"保存"，**Then** 账号列表中出现"TestAccount（已停止）"
3. **Given** 用户选中"TestAccount"并配置了监控聊天和关键词规则，**When** 点击"启动"，**Then** 后台进程启动，状态更新为"运行中"，底部日志区域显示"账号 TestAccount 已启动"
4. **Given** 账号正在运行，**When** 后台进程收到消息并自动回复，**Then** 日志区域实时显示"匹配规则 xxx，延时 5 秒，发送回复"
5. **Given** 用户在配置面板中修改了关键词规则，**When** 点击"保存"，**Then** UI 提示"配置已保存，请重启账号使配置生效"

---

#### 桌面端 UI 详细设计

##### 一、桌面端程序形态

本项目最终形态为一个 Windows 桌面端程序：

- 用户通过图形界面完成所有配置与操作
- 后台进程负责与 Telegram Web 交互，不需要用户手动打开浏览器页面

##### 二、主界面概要

界面包含三个核心区域：

1. **账号列表区**：
   - 展示所有已配置账号（名称、状态图标：运行中/停止）
   - 支持新增账号、编辑账号、删除账号
   - 支持对单个账号执行"启动/停止"操作

2. **配置编辑区**：
   - 针对当前选中账号，编辑：
     - 基本信息（账号名称、浏览器数据目录）
     - 目标聊天列表（私聊/群组）
     - 关键词规则（关键词、匹配方式、回复内容、固定延时、随机延时上限等）
     - 群组邀请链接与入群欢迎文案
     - 其他运行参数（轮询间隔、日志等级等）

3. **运行状态与日志区**：
   - 显示当前账号的运行状态（最近心跳时间、最近一条自动回复概览）
   - 展示简化日志（时间、账号、聊天、触发规则、延时结果等）
   - 提供基础过滤或搜索功能（可按账号或关键字筛选）

##### 三、与后台进程的交互

桌面端负责：

- 将用户在 UI 中的改动写入统一配置（内存或配置文件）
- 启动、停止对应账号的后台运行进程
- 订阅并展示后台进程推送的运行状态与简要日志

后台进程负责：

- 周期性读取配置或在接到变更通知后重新加载配置
- 按当前配置执行自动已读、自动回复、群组加入、OCR 等逻辑
- 向 UI 报告简单状态信息和关键日志事件

##### 四、典型用户操作流程

用户首次使用：

1. 打开桌面程序 → 新增账号 → 填写账号名称与浏览器数据目录
2. 点击"登录 Telegram Web"按钮，让后台为该账号启动带界面的浏览器完成一次登录
3. 在配置编辑区添加目标聊天与关键词规则
4. 点击"启动账号"，后台进程进入隐藏/后台运行模式

用户日常使用：

- 打开程序查看各账号状态
- 根据需要调整某个账号的关键词规则或延时参数
- 随时停止或重启某个账号的后台运行

---

### 用户故事 1 - 自动已读与基础关键词回复 (优先级: P1)

**场景描述**：

用户是一名个体运营者，管理着一个 Telegram 客服账号。每天收到大量重复性咨询（如"营业时间"、"价格查询"等）。用户希望系统能够：

1. 自动将所有新消息标记为已读，避免对方认为无人值守
2. 对包含特定关键词的消息自动回复标准答案
3. 回复延时随机化，模拟真人响应速度

**为何 P1**：这是 MVP 的核心价值，直接解决用户痛点（减少手动操作、提升响应速度）。即使只实现这一功能，用户就能获得显著价值。

**独立测试**：

可以通过以下步骤独立验证：

1. 配置一个测试账号，指定监控的聊天对象
2. 配置一条关键词规则（如"你好"→"感谢咨询，请问有什么能帮到您？"）
3. 从另一个账号发送消息"你好"
4. 验证消息被标记为已读，且在配置的延时后收到自动回复

**验收场景**：

1. **Given** 用户已启动助手并配置了监控的私聊对象，**When** 对方发送包含关键词"营业时间"的消息，**Then** 系统在 3-8 秒内（固定延时 3 秒 + 随机延时 0-5 秒）自动回复"周一至周五 9:00-18:00"
2. **Given** 用户配置了多条规则（如"价格"、"地址"、"联系方式"），**When** 对方发送"请问价格是多少"，**Then** 系统匹配到"价格"关键词并回复对应内容
3. **Given** 用户未配置任何规则，**When** 对方发送任意消息，**Then** 系统仅标记为已读，不发送回复

---

### 用户故事 2 - 多账号支持 (优先级: P2)

**场景描述**：

用户管理着多个 Telegram 账号（如个人账号、工作账号、客服账号），每个账号的监控对象和回复规则不同。用户希望：

1. 在一个配置文件中定义多个账号的信息
2. 同时启动多个账号实例，各自独立运行
3. 每个账号使用独立的浏览器会话（避免登录冲突）

**为何 P2**：扩展了核心功能的应用范围，但不影响单账号场景的 MVP 价值。用户可以先验证单账号功能，再扩展到多账号。

**独立测试**：

1. 配置两个账号（Account A 和 Account B），各自指定不同的监控聊天和规则
2. 同时启动两个进程（或一个进程管理多个账号）
3. 从外部向 Account A 和 Account B 发送消息
4. 验证两个账号分别按各自规则回复，且互不干扰

**验收场景**：

1. **Given** 配置文件中定义了两个账号（Account A 监控私聊，Account B 监控群组），**When** 用户启动助手，**Then** 两个账号各自登录并开始监控
2. **Given** Account A 配置了规则"hello"→"Hi there"，Account B 配置了规则"hello"→"你好"，**When** 两个账号分别收到"hello"消息，**Then** 分别回复对应内容
3. **Given** Account A 的浏览器会话已登录，**When** Account B 启动时，**Then** Account B 使用独立的浏览器数据目录，不影响 Account A 的登录状态

---

### 用户故事 3 - 群组支持与入群欢迎 (优先级: P2)

**场景描述**：

用户需要账号自动加入多个 Telegram 群组（通过邀请链接），并在入群后发送自我介绍消息。加入后，群组消息也参与自动已读和关键词回复。

**为何 P2**：群组场景是常见需求，但不影响私聊场景的核心功能。可以在 P1 功能稳定后再扩展。

**独立测试**：

1. 在配置文件中添加一个群组邀请链接和欢迎消息
2. 启动助手
3. 验证账号自动加入群组并发送欢迎消息
4. 从群组中发送包含关键词的消息，验证系统自动回复

**验收场景**：

1. **Given** 配置文件中定义了群组邀请链接 `https://t.me/joinchat/xxxxx` 和欢迎消息"大家好，我是自动助手"，**When** 助手启动，**Then** 账号自动加入群组并发送欢迎消息
2. **Given** 账号已加入群组且配置了关键词规则，**When** 群组中有人发送"帮助"，**Then** 系统自动回复"请问需要什么帮助？"
3. **Given** 群组邀请链接失效或已加入，**When** 助手启动，**Then** 跳过该群组并记录日志

---

### 用户故事 4 - 截图数字识别（可选扩展功能） (优先级: P3)

**场景描述**：

用户收到包含验证码或订单号的截图消息，需要提取其中的数字并在后续回复中引用（如"您的验证码是 123456，请在 5 分钟内使用"）。

**为何 P3**：OCR 是**可选扩展功能**，不属于 MVP 核心能力。此功能适用于特定场景（验证码、订单号识别），核心自动化流程不依赖此功能。建议在 MVP 稳定后（v1.2+）再实现。

**独立测试**：

1. 配置一条规则：当消息包含图片时，提取数字并回复"识别到的数字是：{数字}"
2. 发送一张清晰的验证码截图
3. 验证系统提取数字并回复

**验收场景**:

1. **Given** 对方发送一张包含验证码"123456"的截图，**When** 系统收到消息，**Then** 提取数字并回复"您的验证码是 123456"
2. **Given** 截图中数字不清晰或无数字，**When** 系统尝试识别，**Then** 记录错误日志并跳过回复
3. **Given** 配置中禁用 OCR 功能，**When** 收到图片消息，**Then** 仅标记为已读，不进行识别

---

### 边界情况

#### 网络与页面异常

- **网络波动导致页面加载失败**：系统重试 3 次，间隔 5 秒。如果仍然失败，记录错误日志并跳过当前消息，继续监控下一条消息。
- **Telegram Web 界面结构变化**：系统检测到选择器失效时，记录关键错误日志（包括页面截图），并向用户发送通知（如果配置了通知渠道）。系统尝试降级模式（简化选择器）或暂停运行等待用户介入。
- **登录会话过期**：系统检测到需要重新登录时，记录错误并停止运行，提示用户手动登录后重启。

#### 配置错误

- **配置文件格式错误**：启动时校验配置文件，如果格式错误（如 JSON/YAML 语法错误），拒绝启动并输出详细错误信息。
- **规则冲突（多条规则匹配同一消息）**：按规则定义顺序执行，仅触发第一条匹配的规则。记录日志提示用户规则冲突。
- **目标聊天不存在**：启动时检查配置的聊天对象是否存在。如果不存在，记录警告日志并跳过该聊天。

#### OCR 失败场景

- **图片中无数字或识别失败**：记录警告日志，不发送回复，继续处理下一条消息。
- **图片加载失败**：重试 2 次，如果仍然失败，记录错误并跳过该图片。

#### 并发与状态管理

- **同一账号同时收到多条消息**：按时间顺序逐条处理，确保延时和回复顺序符合预期。
- **多账号同时运行**：各账号使用独立的浏览器会话和数据目录，确保互不干扰。

---

## 功能需求

### 功能需求 - 自动已读

- **FR-001**: 系统**必须**监控配置文件中指定的私聊和群组对象
- **FR-002**: 系统**必须**采用定时轮询方式检测新消息（轮询间隔详见 NFR-001）
- **FR-003**: 系统**必须**在检测到新消息后，使用 Playwright `wait_for_selector` 等待必要元素加载，超时后记录日志
- **FR-004**: 系统**必须**在必要元素加载后，自动进入对应会话并标记为已读
- **FR-005**: 系统**必须**记录每次已读操作的日志（包括时间、聊天对象、消息数量）
- **FR-006**: 系统**必须**在页面加载失败时重试（重试策略详见 NFR-007）

### 功能需求 - 关键词自动回复

- **FR-007**: 系统**必须**支持在配置文件中定义多条关键词规则，每条规则包含：
  - **匹配条件**：字面量关键词字符串，支持通配符 `*`（匹配0个或多个任意字符）和 `?`（匹配单个任意字符）。通配符遵循 Python `fnmatch` 模块规范，不支持正则表达式（MVP 阶段）。特殊字符如 `[`、`]`、`\` 需要转义（如 `\[`、`\]`、`\\`）
  - **回复内容**：字符串，支持变量替换（如 `{ocr_result}`，v1.2+ OCR 功能）
  - **固定延时**：秒数（整数或浮点数）
  - **随机延时上限**：秒数（整数或浮点数）
  - **可选字段**：`use_regex`（预留，v1.3+）、`case_sensitive`（默认 false）、`next_id`（预留，v2.0多节点流程）
- **FR-008**: 系统**必须**默认不区分大小写进行匹配，除非规则中 `case_sensitive` 设置为 true
- **FR-009**: 系统**必须**按照规则定义顺序逐条匹配，触发第一条匹配的规则
- **FR-010**: 系统**必须**先遍历所有规则收集匹配项，如发现多条规则匹配，记录所有匹配的规则到日志（WARNING 级别），然后仅执行第一条匹配规则的动作
- **FR-011**: 系统**必须**在发送回复前，按照"固定延时 + [0, 随机延时上限]"计算实际延时，使用系统真随机数生成器
- **FR-012**: 系统**必须**在调试模式下支持通过配置文件指定 `random_seed` 参数，用于调试时重现延时行为
- **FR-013**: 系统**必须**记录每次回复操作的日志（包括匹配的规则、延时时长、回复内容）
- **FR-014**: 系统**必须**支持针对不同聊天对象配置不同的规则集

### 功能需求 - 群组支持

- **FR-015**: 系统**必须**支持在配置文件中定义群组邀请链接列表
- **FR-016**: 系统**必须**在启动时自动打开邀请链接并加入群组
- **FR-017**: 系统**必须**在网络错误时重试 3 次，其他失败（链接失效、已加入）直接跳过并记录日志
- **FR-018**: 系统**必须**在成功加入群组后，随机等待 3-5 秒（使用 `random.uniform(3, 5)`）确保页面稳定，然后自动发送配置的欢迎消息
- **FR-019**: 系统**必须**默认监控所有群组消息，通过规则配置控制回复范围

### 功能需求 - OCR 数字识别

- **FR-020**: 系统**必须**使用 Tesseract OCR（通过 pytesseract 库）从聊天图片中提取 0-9 数字字符串
- **FR-021**: 系统**必须**对图片进行极简预处理（灰度化 + 简单二值化），提高识别成功率
- **FR-022**: 系统**必须**在配置文件中支持引用 OCR 提取的数字（如在回复内容中使用变量 `{ocr_result}`）
- **FR-023**: 系统**必须**在 OCR 失败时记录警告日志并跳过该图片
- **FR-024**: 系统**禁止**缓存 OCR 结果，每次**必须**重新识别

### 功能需求 - 多账号支持

- **FR-025**: 系统**必须**支持在 YAML 配置文件中定义多个账号，每个账号包含：账号名称、浏览器数据目录路径（可选）、监控聊天列表、规则配置、群组邀请链接
- **FR-026**: 系统**必须**为每个账号提供默认浏览器数据目录 `./browser_data/{account_name}/`，允许在配置中覆盖为绝对路径
- **FR-027**: 系统**必须**采用一账号一进程模式运行，CLI 命令形式为 `teleflow run --account <name>`
- **FR-028**: 系统**必须**确保不同账号的配置和运行状态互不干扰

### 功能需求 - 运行与配置

- **FR-029**: 系统**必须**使用 YAML 格式的配置文件，依赖 pyyaml 库进行解析
- **FR-030**: 系统**必须**提供命令行入口，支持以下操作：
  - 启动指定账号：`teleflow run --config <path> [--show-browser] [--debug] [--random-seed <int>]`
  - 校验配置文件：`teleflow validate-config --config <path>`
  - 显示版本：`teleflow --version`
- **FR-031**: 系统**必须**确保命令行参数优先级高于配置文件，但仅覆盖少数字段：
  - `--debug`：启用调试模式（详细日志）
  - `--show-browser`：显示浏览器窗口（覆盖 headless 配置）
  - `--config`：指定配置文件路径（默认 ./config.yaml）
  - `--random-seed <int>`：指定随机种子（全局作用于所有延时计算，仅调试模式有效）
- **FR-032**: 系统**必须**在启动前校验配置文件格式，如果格式错误则拒绝启动并输出详细错误信息
- **FR-033**: 系统**必须**使用 Python logging 模块记录结构化日志，同时输出到控制台和文件
- **FR-034**: 系统**必须**使用 `TimedRotatingFileHandler` 实现按天轮转的日志文件管理
- **FR-035**: 系统**必须**支持按日志级别过滤（INFO/WARNING/ERROR）
- **FR-036**: 系统**必须**在调试模式下输出详细的执行步骤（如页面元素定位、规则匹配过程、延时计算结果）
- **FR-037**: 系统**必须**在异常退出后，重启时从当前时间开始监控，不做消息级状态持久化

### 功能需求 - 桌面端 UI（v1.2+ 扩展功能，非 MVP）

**⚠️ 注意**：以下需求属于 **v1.2+** 扩展功能，**不属于 MVP（v1.0）范围**。MVP 仅提供命令行界面（CLI）。

#### 基础监控 UI（v1.2，P2 优先级）

- **FR-042**（v1.2）: 系统**应当**提供 Windows 桌面端图形界面（基础版），包含两个核心区域：账号状态区、日志查看区
- **FR-043**（v1.2）: 账号状态区**应当**展示所有已配置账号的名称和运行状态（运行中/已停止），仅支持只读查看
- **FR-047**（v1.2）: 日志查看区**应当**实时展示选中账号的运行日志（最近 100 条或按时间筛选）
- **FR-048**（v1.2）: 日志查看区**应当**提供基础日志过滤功能（按账号、关键字、日志级别筛选）
- **FR-052**（v1.2）: UI **应当**定期轮询后台进程的存活状态（每 5 秒），更新账号列表中的状态图标
- **FR-053**（v1.2）: UI **应当**订阅后台进程推送的日志事件（通过文件监听），并在日志区域实时展示

#### 高级管理 UI（v1.3+，P3 优先级）

- **FR-044**（v1.3+）: 账号列表区**应当**为每个账号提供"启动/停止"按钮，点击后能够控制对应账号的后台进程
- **FR-045**（v1.3+）: 配置编辑区**应当**支持编辑选中账号的基本信息（账号名称、浏览器数据目录）、目标聊天列表、关键词规则、群组邀请链接、运行参数
- **FR-046**（v1.3+）: 配置编辑区**应当**为关键词规则提供表单化编辑界面，包括：关键词输入、回复内容输入、固定延时输入、随机延时上限输入、匹配方式选择（不区分大小写/区分大小写）
- **FR-049**（v1.3+）: UI **应当**在用户保存配置后，将配置写入 YAML 文件或通过 IPC 通知后台进程重新加载配置
- **FR-050**（v1.3+）: UI **应当**在用户点击"启动账号"时，通过子进程管理启动对应的 Python 后台进程，传递账号名称作为参数
- **FR-051**（v1.3+）: UI **应当**在用户点击"停止账号"时，向对应的后台进程发送停止信号（SIGTERM 或通过 IPC），并等待进程优雅退出
- **FR-054**（v1.3+）: UI **应当**在用户首次添加账号时，提供"登录 Telegram Web"按钮，启动带界面的浏览器（headless=False）供用户手动登录
- **FR-055**（v1.3+）: UI **应当**在用户修改配置后未保存时，弹出提示"有未保存的更改，是否保存？"，避免配置丢失

### 非功能需求

#### 性能需求

- **NFR-001**: 系统**必须**使用定时轮询方式检测新消息，轮询间隔为 2-3 秒
- **NFR-002**: 系统在收到新消息后，**必须**在 2 秒内完成已读标记（不包括网络延时）
- **NFR-003**: 系统在匹配到关键词规则后，延时计算和回复发送的总耗时**必须**不超过配置延时 + 1 秒

#### 稳定性需求

- **NFR-004**: 系统**必须**能够连续运行 24 小时不崩溃，处理至少 1000 条普通文本消息（其中约 50% 命中关键词规则并触发自动回复）。测试场景：单账号、单聊天、10 条关键词规则、平均延时 5 秒
- **NFR-005**: 系统在遇到页面加载失败、选择器失效等异常时，**必须**记录详细错误日志，并在 3 次重试后优雅降级（跳过当前消息继续运行）
- **NFR-006**: 系统**必须**在异常退出后，重启时能够从当前时间继续监控，不丢失关键配置

#### 错误恢复需求

- **NFR-007**: 网络错误（页面加载失败）时，系统**必须**重试 3 次，间隔 5 秒，仍失败则记录错误并跳过
- **NFR-008**: 登录会话过期时，系统**必须**检测并停止运行，记录错误并提示用户手动登录后重启
- **NFR-009**: 选择器失效（Telegram Web 界面变化）时，系统**必须**实施选择器回退机制：
  - 为每个关键操作（定位聊天、检测消息、标记已读、发送消息）配置多个候选选择器（按优先级排序）
  - 依次尝试候选选择器，直到成功或全部失败
  - 全部失败时，记录关键错误日志（包括页面截图和失败的选择器列表），并暂停运行等待用户介入
  - 系统**应当**在配置文件中预留 `selector_overrides` 字段，允许用户自定义选择器（v1.3+ 高级功能）

#### 数据隐私需求

- **NFR-010**: 所有浏览器数据（会话、Cookie、缓存）**必须**仅存储在本地目录（`./browser_data/{account_name}/`）
- **NFR-011**: 系统**不得**将任何用户数据上传到云端或第三方服务器
- **NFR-012**: 日志文件**必须**仅存储在本地目录（`./logs/`），不包含敏感信息（如密码、Token）

### 关键实体

#### 账号（Account）

表示一个 Telegram 账号的配置信息，在 YAML 配置文件中定义，包含：

- 账号名称（用于日志和区分）
- 浏览器数据目录路径（可选，默认 `./browser_data/{account_name}/`，可覆盖为绝对路径）
- 监控的聊天对象列表（优先使用用户名/@username，数字 ID 为可选高级字段）
- 关键词规则集
- 群组邀请链接列表
- 调试参数（如 `random_seed`，可选）

#### 聊天对象（Chat）

表示一个私聊或群组，包含：

- 聊天类型（私聊/群组）
- 聊天唯一标识（优先使用用户名/@username 或聊天名称，数字 ID 为高级可选字段）
- 关联的规则集（该聊天专用的规则）

#### 关键词规则（KeywordRule）

表示一条自动回复规则，包含：

- 规则 ID（用于日志和排序）
- 匹配条件（MVP 阶段：字面量关键词 + 通配符 `*`、`?`）
- 回复内容（纯文本，支持变量如 `{ocr_result}`）
- 固定延时（秒）
- 随机延时上限（秒）
- `case_sensitive`（可选，默认 false）
- `use_regex`（预留字段，供后续版本支持完整正则）

#### 节点（Node）- 预留

表示多节点流程中的一个节点，包含：

- 节点 ID
- 判定条件（如关键词匹配、OCR 结果匹配）
- 动作类型（回复/记录状态/跳过）
- 动作内容（回复文本等）
- 下一步节点 ID

#### 消息（Message）

表示一条 Telegram 消息，包含：

- 消息文本内容
- 发送者信息
- 时间戳
- 是否包含图片
- OCR 提取结果（如果有）

---

## 成功标准

### 可测量结果

- **SC-001**: 用户能够在 5 分钟内通过桌面端 UI 完成账号配置（包括账号创建、添加至少 1 个聊天对象、配置至少 3 条规则），并成功启动账号
- **SC-002**: 桌面端 UI **必须**在启动后 3 秒内加载完成并显示主界面（账号列表、配置面板、日志区域）
- **SC-003**: 用户在 UI 中修改配置并保存后，配置**必须**在 2 秒内写入 YAML 文件，后台进程**必须**在 5 秒内检测到配置变更
- **SC-004**: 用户在 UI 中点击"启动账号"后，后台进程**必须**在 10 秒内启动完成，UI 状态图标**必须**更新为"运行中"
- **SC-005**: 用户在 UI 中点击"停止账号"后，后台进程**必须**在 5 秒内优雅退出，UI 状态图标**必须**更新为"已停止"
- **SC-006**: UI 日志区域**必须**在后台进程产生新日志后 2 秒内展示最新日志（通过文件监听或 IPC）
- **SC-007**: 系统在收到新消息后，**必须**在 2 秒内标记为已读（不包括网络延时）
- **SC-008**: 系统在匹配到关键词规则后，**必须**按照配置的延时（固定延时 + 随机延时）发送回复，误差不超过 1 秒
- **SC-009**: 后台进程**必须**连续运行 24 小时不崩溃，处理至少 1000 条消息
- **SC-010**: 系统在遇到页面加载失败、选择器失效等异常时，**必须**记录详细错误日志，并在 3 次重试后优雅降级（跳过当前消息继续运行）
- **SC-011**: 用户**必须**能够通过 UI 日志区域快速定位问题（如规则匹配失败、OCR 识别失败），日志包含时间、账号、聊天对象、事件详情
- **SC-012**: 多账号场景下，3 个账号同时运行时，各账号的消息处理延时**必须**不超过单账号场景的 1.5 倍
- **SC-013**: OCR 功能对清晰截图（分辨率 >= 720p，数字字体 >= 12pt）的识别准确率**必须**达到 90% 以上
- **SC-014**: UI **必须**在用户修改配置但未保存就尝试关闭窗口时，弹出确认提示，避免配置丢失

---

## 业务流程

### 核心流程：消息处理与自动回复

```text
1. 系统启动
   ├─ 加载配置文件（账号、聊天对象、规则）
   ├─ 校验配置格式
   ├─ 启动浏览器会话（每个账号独立）
   └─ 登录 Telegram Web（复用已保存的会话）

2. 消息监控循环
   ├─ 检测新消息（轮询或监听 DOM 变化）
   ├─ 标记为已读
   └─ 提取消息内容

3. 规则匹配
   ├─ 按配置顺序遍历规则
   ├─ 检查是否匹配关键词或正则
   └─ 如果匹配：
       ├─ 计算延时 = 固定延时 + random(0, 随机延时上限)
       ├─ 等待延时
       ├─ 发送回复
       └─ 记录日志
   └─ 如果不匹配：继续检查下一条规则

4. OCR 处理（如果消息包含图片）
   ├─ 下载图片
   ├─ 提取数字字符串
   ├─ 将结果保存到消息对象
   └─ 在规则匹配时可引用 {ocr_result}

5. 异常处理
   ├─ 网络错误：重试 3 次
   ├─ 选择器失效：记录错误并尝试降级模式
   ├─ OCR 失败：记录警告并跳过
   └─ 配置错误：拒绝启动并提示用户

6. 日志记录
   ├─ INFO: 启动、登录、消息处理、规则匹配、回复发送
   ├─ WARNING: OCR 失败、规则冲突、聊天对象不存在
   └─ ERROR: 网络错误、页面异常、登录失效
```

### 群组加入流程

```text
1. 系统启动时读取群组邀请链接列表
2. 逐个打开邀请链接
3. 检查是否已加入
   ├─ 已加入：跳过并记录日志
   └─ 未加入：
       ├─ 点击"加入群组"按钮
       ├─ 等待页面加载
       ├─ 发送欢迎消息
       └─ 记录日志
4. 如果链接失效：记录错误并跳过
```

---

## 假设与约束

### 假设

1. 用户已在 Telegram Web 上完成初次登录，系统仅需复用已保存的浏览器会话
2. 用户提供的聊天对象名称或用户名准确无误
3. Telegram Web 的页面结构在短期内保持相对稳定
4. 用户提供的截图清晰度足够支持基础 OCR 识别（分辨率 >= 720p，数字字体 >= 12pt）
5. 用户环境已安装 Tesseract OCR 引擎（pytesseract 依赖）
6. 用户接受 MVP 阶段异常退出后可能遗漏部分消息的自动回复

### 约束

1. 系统仅在 Windows 平台运行
2. 系统不使用 Telegram 官方 API，所有操作通过 Playwright 驱动 Telegram Web 页面自动化实现
3. OCR 功能仅支持数字识别，不支持文字、符号或复杂场景
4. 配置文件格式**唯一**采用 YAML（.yaml 或 .yml 扩展名），通过 pyyaml 库解析，**不支持 JSON 或其他格式**
5. MVP 阶段系统不提供图形界面，仅通过命令行操作（桌面 UI 为 v1.1+ 扩展功能）
6. MVP 阶段仅支持**单节点**关键词规则（单条规则命中 → 延时 → 回复），不实现多节点流程引擎
7. MVP 阶段仅支持字面量关键词 + 通配符（`*`、`?`）匹配，完整正则表达式支持延后实现
8. MVP 阶段采用单账号模式，多账号支持为 v1.1 扩展功能
9. MVP 阶段异常退出后不做消息级状态恢复，重启后从当前时间开始监控

---

## 未来规划

### 多节点流程引擎（v2.0+）

**概述**：

多节点流程引擎是未来版本（v2.0 及以后）的高级功能，用于支持复杂的对话逻辑，如多轮问答、条件分支、状态记忆等场景。本节仅用于描述未来方向，**对当前版本（v1.0-v1.3）不构成实现约束**。

**功能特性**（v2.0+ 规划）：

1. **节点定义**：支持由若干"节点"组成的流程，每个节点包含：
   - 节点 ID（唯一标识）
   - 判定条件（基于消息内容、发送者、时间等条件）
   - 动作类型（回复、记录状态、跳过、跳转等）
   - 动作内容（回复文本、状态变量等）
   - 下一节点指向（支持条件跳转）

2. **流程控制**：
   - 支持节点间的顺序执行和条件跳转
   - 支持对配置进行基本的环检测，防止无限循环
   - 支持流程超时和异常退出机制

3. **状态管理**：
   - 为每个聊天实例维护独立的流程状态
   - 支持状态变量的读取和写入
   - 支持状态持久化（内存或文件）

4. **兼容性设计**：
   - 向后兼容当前版本的单节点关键词规则
   - 单节点规则可视为"只有一个节点且无跳转"的特殊流程

**当前版本设计原则**：

为了便于未来演进为多节点流程引擎，当前版本（v1.0）在实现**单节点关键词规则**时，数据结构设计应尽量与未来"节点"的概念兼容：

1. **数据模型兼容性**：
   - 规则（Rule）的数据结构应包含"条件"（keywords, case_sensitive）和"动作"（reply_text, delay）的明确划分
   - 字段命名应保持抽象和可扩展，例如使用 `condition` 而非 `keywords_only`，使用 `action` 而非 `reply_only`
   - 为未来扩展预留字段（如 `node_id`、`next_node`），但当前版本不使用这些字段

2. **接口设计可扩展**：
   - 规则匹配器（RuleMatcher）应设计为接口，未来可替换为节点执行引擎
   - 状态管理接口应预留，当前版本使用内存状态，未来可替换为持久化状态

3. **不实现具体逻辑**：
   - 当前版本**不实现**节点跳转、状态机、环检测等多节点流程逻辑
   - 当前版本**不定义**详细的节点数据结构或流程配置格式
   - 当前版本**不编写**多节点流程相关的代码或测试

**触发条件**：

仅在多个用户明确反馈需要复杂对话流程（如多轮问答、条件分支、状态记忆）时，才启动 v2.0 开发。

**示例场景**（仅供参考）：

```yaml
# 未来版本配置示例（当前版本不支持）
flows:
  - flow_id: "price_inquiry"
    nodes:
      - node_id: "check_keyword"
        condition:
          type: "keyword_match"
          keywords: ["价格", "多少钱"]
        action:
          type: "reply"
          text: "我们的价格表如下：A套餐 100元，B套餐 200元。请问需要了解详情吗？"
        next_node: "wait_for_response"
      
      - node_id: "wait_for_response"
        condition:
          type: "keyword_match"
          keywords: ["详情", "了解更多"]
        action:
          type: "reply"
          text: "A套餐包含...，B套餐包含..."
        next_node: "end"
      
      - node_id: "end"
        action:
          type: "finish"
```
