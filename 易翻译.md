# ğŸŒ æ˜“ç¿»è¯‘åŠŸèƒ½æ¶æ„è®¾è®¡ä¸å®ç°åˆ†æ

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

åŸºäºç°æœ‰ Telegram Web Auto Reply æ¶æ„ï¼Œè®¾è®¡å®Œæ•´çš„ç¿»è¯‘åŠŸèƒ½ç”Ÿæ€ï¼ŒåŒ…æ‹¬**æ¶ˆæ¯è‡ªåŠ¨ç¿»è¯‘ã€ç¾¤å‘å®šæ—¶å‘é€ã€ä¼šè¯ç®¡ç†ã€ç²‰ä¸å¤‡æ³¨**ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚é‡‡ç”¨**å¾®æœåŠ¡æ¶æ„**ï¼Œç¡®ä¿é«˜æ€§èƒ½ã€å¯æ‰©å±•æ€§å’Œç”¨æˆ·ä½“éªŒã€‚

---

## ğŸ—ï¸ æ•´ä½“æ¶æ„è®¾è®¡

### æŠ€æœ¯æ ˆç»„åˆ

```typescript
{
  "ç¿»è¯‘å¼•æ“": "Google Translate API + DeepL API + ç™¾åº¦ç¿»è¯‘",
  "æ¶ˆæ¯é˜Ÿåˆ—": "Redis + Bull Queue",
  "è°ƒåº¦ç³»ç»Ÿ": "node-cron + Quartz",
  "ä¼šè¯ç®¡ç†": "SQLite + IndexedDB",
  "å¤‡æ³¨ç³»ç»Ÿ": "SQLite + å…¨æ–‡æœç´¢",
  "çŠ¶æ€ç®¡ç†": "Zustand + EventSource",
  "å®æ—¶é€šä¿¡": "WebSocket + Server-Sent Events"
}
```

### æ ¸å¿ƒæ¶æ„æ¨¡å¼

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç¿»è¯‘æœåŠ¡å±‚     â”‚    â”‚   æ¶ˆæ¯è°ƒåº¦å±‚     â”‚    â”‚   ä¼šè¯ç®¡ç†å±‚     â”‚
â”‚                â”‚    â”‚                â”‚    â”‚                â”‚
â”‚ â€¢ ç¿»è¯‘å¼•æ“ç®¡ç†   â”‚    â”‚ â€¢ å®šæ—¶ä»»åŠ¡è°ƒåº¦   â”‚    â”‚ â€¢ ä¼šè¯çŠ¶æ€è¿½è¸ª   â”‚
â”‚ â€¢ è¯­è¨€æ£€æµ‹      â”‚    â”‚ â€¢ ç¾¤å‘é˜Ÿåˆ—ç®¡ç†   â”‚    â”‚ â€¢ æœªè¯»æ¶ˆæ¯ç­›é€‰   â”‚
â”‚ â€¢ ç¼“å­˜ä¼˜åŒ–      â”‚    â”‚ â€¢ å¤±è´¥é‡è¯•æœºåˆ¶   â”‚    â”‚ â€¢ æ¶ˆæ¯åˆ†ç±»      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚              æ ¸å¿ƒæ¶ˆæ¯å¤„ç†å¼•æ“                      â”‚
         â”‚  â€¢ æ¶ˆæ¯æ‹¦æˆª â€¢ ç¿»è¯‘å¤„ç† â€¢ è‡ªåŠ¨å‘é€ â€¢ çŠ¶æ€åŒæ­¥        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                ç°æœ‰åŸºç¡€æ¶æ„                        â”‚
         â”‚  â€¢ Playwrightè‡ªåŠ¨åŒ– â€¢ IPCé€šä¿¡ â€¢ æ•°æ®å­˜å‚¨          â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

### 1. ç¿»è¯‘å¼•æ“æ¶æ„

#### å¤šç¿»è¯‘å¼•æ“æ”¯æŒ

```typescript
// ç¿»è¯‘å¼•æ“æŠ½è±¡æ¥å£
interface TranslationEngine {
  name: string;
  detectLanguage(text: string): Promise<string>;
  translate(text: string, from: string, to: string): Promise<TranslationResult>;
  getSupportedLanguages(): Promise<Language[]>;
  getUsageStats(): Promise<UsageStats>;
}

// Google Translate å¼•æ“å®ç°
class GoogleTranslateEngine implements TranslationEngine {
  name = 'google';

  async translate(text: string, from: string, to: string): Promise<TranslationResult> {
    const apiKey = await this.getApiKey();
    const url = `https://translation.googleapis.com/language/translate/v2?key=${apiKey}`;

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        q: text,
        source: from,
        target: to,
        format: 'text'
      })
    });

    const data = await response.json();
    return {
      originalText: text,
      translatedText: data.data.translations[0].translatedText,
      sourceLanguage: from,
      targetLanguage: to,
      engine: this.name,
      confidence: data.data.translations[0].confidence || 0.95
    };
  }
}

// DeepL å¼•æ“å®ç°
class DeepLEngine implements TranslationEngine {
  name = 'deepl';

  async translate(text: string, from: string, to: string): Promise<TranslationResult> {
    const apiKey = await this.getApiKey();
    const url = 'https://api-free.deepl.com/v2/translate';

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `DeepL-Auth-Key ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: [text],
        source_lang: from.toUpperCase(),
        target_lang: to.toUpperCase()
      })
    });

    const data = await response.json();
    return {
      originalText: text,
      translatedText: data.translations[0].text,
      sourceLanguage: from,
      targetLanguage: to,
      engine: this.name,
      confidence: 0.98 // DeepL é€šå¸¸è´¨é‡æ›´é«˜
    };
  }
}

// ç¿»è¯‘å¼•æ“ç®¡ç†å™¨
class TranslationEngineManager {
  private engines: Map<string, TranslationEngine> = new Map();
  private fallbackOrder: string[] = ['deepl', 'google', 'baidu'];

  constructor() {
    this.engines.set('google', new GoogleTranslateEngine());
    this.engines.set('deepl', new DeepLEngine());
    this.engines.set('baidu', new BaiduTranslateEngine());
  }

  async translateWithFallback(
    text: string,
    from: string,
    to: string
  ): Promise<TranslationResult> {
    let lastError: Error | null = null;

    for (const engineName of this.fallbackOrder) {
      try {
        const engine = this.engines.get(engineName);
        if (!engine) continue;

        const result = await engine.translate(text, from, to);

        // ç¼“å­˜ç¿»è¯‘ç»“æœ
        await this.cacheTranslation(result);

        return result;
      } catch (error) {
        lastError = error as Error;
        console.warn(`ç¿»è¯‘å¼•æ“ ${engineName} å¤±è´¥:`, error);
        continue;
      }
    }

    throw new Error(`æ‰€æœ‰ç¿»è¯‘å¼•æ“éƒ½å¤±è´¥äº†: ${lastError?.message}`);
  }
}
```

#### è¯­è¨€æ£€æµ‹ä¸è‡ªåŠ¨ç¿»è¯‘

```typescript
// æ™ºèƒ½è¯­è¨€æ£€æµ‹
class LanguageDetector {
  private translationManager: TranslationEngineManager;

  async detectAndTranslate(
    message: string,
    targetLanguage: string,
    userPreferences: UserTranslationPrefs
  ): Promise<TranslationResult | null> {
    // 1. æ£€æµ‹æ¶ˆæ¯è¯­è¨€
    const detectedLanguage = await this.detectLanguage(message);

    // 2. æ£€æŸ¥æ˜¯å¦éœ€è¦ç¿»è¯‘
    if (!this.shouldTranslate(detectedLanguage, targetLanguage, userPreferences)) {
      return null;
    }

    // 3. æ‰§è¡Œç¿»è¯‘
    const result = await this.translationManager.translateWithFallback(
      message,
      detectedLanguage,
      targetLanguage
    );

    // 4. è®°å½•ç¿»è¯‘å†å²
    await this.recordTranslationHistory(result);

    return result;
  }

  private shouldTranslate(
    detectedLang: string,
    targetLang: string,
    prefs: UserTranslationPrefs
  ): boolean {
    // æ£€æŸ¥ç”¨æˆ·åå¥½è®¾ç½®
    if (!prefs.autoTranslate) return false;

    // æ£€æŸ¥è¯­è¨€æ˜¯å¦ç›¸åŒ
    if (detectedLang === targetLang) return false;

    // æ£€æŸ¥æ’é™¤è¯­è¨€åˆ—è¡¨
    if (prefs.excludedLanguages.includes(detectedLang)) return false;

    // æ£€æŸ¥æ˜¯å¦åœ¨ç‰¹å®šæ—¶é—´æ®µå†…
    const now = new Date();
    const currentHour = now.getHours();
    if (prefs.quietHours?.start && prefs.quietHours?.end) {
      if (currentHour >= prefs.quietHours.start && currentHour <= prefs.quietHours.end) {
        return false;
      }
    }

    return true;
  }
}

// ç¿»è¯‘ç»“æœæ¥å£
interface TranslationResult {
  originalText: string;
  translatedText: string;
  sourceLanguage: string;
  targetLanguage: string;
  engine: string;
  confidence: number;
  timestamp: number;
}
```

### 2. è‡ªåŠ¨æ¶ˆæ¯ç¿»è¯‘æœºåˆ¶

#### æ¶ˆæ¯æ‹¦æˆªä¸å¤„ç†

```typescript
// åŸºäºç°æœ‰ MessageActions çš„æ‰©å±•
class TranslatedMessageActions extends MessageActions {
  private translationManager: TranslationEngineManager;
  private languageDetector: LanguageDetector;
  private userPrefs: UserTranslationPrefs;

  constructor(page: Page, translationManager: TranslationEngineManager) {
    super(page);
    this.translationManager = translationManager;
    this.languageDetector = new LanguageDetector(translationManager);
  }

  async sendTranslatedMessage(
    originalMessage: string,
    targetLanguage: string,
    options: TranslationOptions = {}
  ): Promise<boolean> {
    try {
      // 1. æ£€æµ‹å¹¶ç¿»è¯‘æ¶ˆæ¯
      const translation = await this.languageDetector.detectAndTranslate(
        originalMessage,
        targetLanguage,
        this.userPrefs
      );

      if (!translation) {
        // ä¸éœ€è¦ç¿»è¯‘ï¼Œç›´æ¥å‘é€åŸæ¶ˆæ¯
        return await this.send_message(originalMessage);
      }

      // 2. æ ¹æ®é€‰é¡¹å†³å®šå‘é€æ ¼å¼
      let finalMessage = translation.translatedText;

      if (options.includeOriginal) {
        finalMessage = this.formatBilingualMessage(
          translation.originalText,
          translation.translatedText,
          options.format
        );
      }

      if (options.addTranslationNote) {
        finalMessage += `\n\nğŸŒ [è‡ªåŠ¨ç¿»è¯‘: ${translation.engine}]`;
      }

      // 3. å‘é€ç¿»è¯‘åçš„æ¶ˆæ¯
      const success = await this.send_message(finalMessage);

      if (success) {
        // 4. è®°å½•ç¿»è¯‘æ—¥å¿—
        await this.logTranslation(translation, options);
      }

      return success;

    } catch (error) {
      console.error('å‘é€ç¿»è¯‘æ¶ˆæ¯å¤±è´¥:', error);
      // ç¿»è¯‘å¤±è´¥æ—¶å›é€€åˆ°åŸæ¶ˆæ¯
      return await this.send_message(originalMessage);
    }
  }

  private formatBilingualMessage(
    original: string,
    translated: string,
    format: 'separate' | 'inline' | 'brackets' = 'separate'
  ): string {
    switch (format) {
      case 'separate':
        return `${translated}\n\n--- åŸæ–‡ ---\n${original}`;
      case 'inline':
        return `${translated} (åŸæ–‡: ${original})`;
      case 'brackets':
        return `[${translated}] ${original}`;
      default:
        return translated;
    }
  }
}

// ç¿»è¯‘é€‰é¡¹é…ç½®
interface TranslationOptions {
  includeOriginal?: boolean;
  format?: 'separate' | 'inline' | 'brackets';
  addTranslationNote?: boolean;
  delayBeforeSend?: number;
}
```

#### å®æ—¶æ¶ˆæ¯ç¿»è¯‘ç›‘å¬

```typescript
// æ¶ˆæ¯ç›‘å¬å™¨æ‰©å±•
class TranslationMessageListener {
  private translationManager: TranslationEngineManager;
  private messageActions: TranslatedMessageActions;

  async startListening(accountId: string): Promise<void> {
    // ç›‘å¬æ–°æ¶ˆæ¯äº‹ä»¶
    this.on('new_message', async (message: TelegramMessage) => {
      await this.handleIncomingMessage(message, accountId);
    });

    // ç›‘å¬å‘é€æ¶ˆæ¯äº‹ä»¶
    this.on('send_message', async (message: string, chatId: string) => {
      await this.handleOutgoingMessage(message, chatId, accountId);
    });
  }

  private async handleIncomingMessage(
    message: TelegramMessage,
    accountId: string
  ): Promise<void> {
    try {
      // è·å–ç”¨æˆ·ç¿»è¯‘åå¥½
      const userPrefs = await this.getUserTranslationPrefs(accountId);

      if (!userPrefs.autoTranslateIncoming) {
        return;
      }

      // ç¿»è¯‘æ¥æ”¶åˆ°çš„æ¶ˆæ¯
      const translation = await this.languageDetector.detectAndTranslate(
        message.content,
        userPrefs.defaultLanguage,
        userPrefs
      );

      if (translation) {
        // æ˜¾ç¤ºç¿»è¯‘ç»“æœï¼ˆå¯é€‰ï¼‰
        if (userPrefs.showTranslationTooltip) {
          await this.showTranslationTooltip(message.id, translation);
        }

        // è§¦å‘ç¿»è¯‘äº‹ä»¶
        this.emit('message_translated', {
          originalMessage: message,
          translation
        });
      }

    } catch (error) {
      console.error('å¤„ç†æ¥æ”¶æ¶ˆæ¯ç¿»è¯‘å¤±è´¥:', error);
    }
  }

  private async handleOutgoingMessage(
    message: string,
    chatId: string,
    accountId: string
  ): Promise<void> {
    try {
      const userPrefs = await this.getUserTranslationPrefs(accountId);

      if (!userPrefs.autoTranslateOutgoing) {
        return;
      }

      // è·å–èŠå¤©å¯¹è±¡çš„è¯­è¨€åå¥½
      const chatPrefs = await this.getChatTranslationPrefs(chatId);
      const targetLanguage = chatPrefs.targetLanguage || userPrefs.defaultLanguage;

      // å‘é€ç¿»è¯‘åçš„æ¶ˆæ¯
      await this.messageActions.sendTranslatedMessage(
        message,
        targetLanguage,
        userPrefs.outgoingOptions
      );

    } catch (error) {
      console.error('å¤„ç†å‘é€æ¶ˆæ¯ç¿»è¯‘å¤±è´¥:', error);
    }
  }
}
```

### 3. è‡ªåŠ¨å‘é€ä¸ç¾¤å‘ç³»ç»Ÿ

#### æ¶ˆæ¯é˜Ÿåˆ—ç®¡ç†

```typescript
// åŸºäº Bull Queue çš„æ¶ˆæ¯é˜Ÿåˆ—
interface ScheduledMessage {
  id: string;
  content: string;
  targetChatIds: string[];
  scheduledTime: Date;
  translationOptions?: TranslationOptions;
  retryConfig: RetryConfig;
  status: 'pending' | 'processing' | 'completed' | 'failed';
}
```

class MessageQueueManager {
  private messageQueue: Queue;
  private translationManager: TranslationEngineManager;

  constructor() {
    // åˆå§‹åŒ– Redis è¿æ¥å’Œé˜Ÿåˆ—
    this.messageQueue = new Queue('message sending', {
      redis: { port: 6379, host: '127.0.0.1' },
      defaultJobOptions: {
        removeOnComplete: 100,
        removeOnFail: 50,
        attempts: 3,
        backoff: 'exponential'
      }
    });

    this.setupProcessors();
  }

  // è°ƒåº¦å•æ¡æ¶ˆæ¯
  async scheduleMessage(message: ScheduledMessage): Promise<string> {
    const job = await this.messageQueue.add('send-message', message, {
      delay: message.scheduledTime.getTime() - Date.now(),
      jobId: message.id
    });

    return job.id.toString();
  }

  // è°ƒåº¦ç¾¤å‘æ¶ˆæ¯
  async scheduleBulkMessage(
    content: string,
    targetChatIds: string[],
    scheduledTime: Date,
    options: {
      translationOptions?: TranslationOptions;
      batchSize?: number;
      delayBetweenBatches?: number;
    } = {}
  ): Promise<string[]> {
    const jobIds: string[] = [];
    const batchSize = options.batchSize || 10;
    const delayBetween = options.delayBetweenBatches || 1000;

    // åˆ†æ‰¹å¤„ç†é¿å…APIé™åˆ¶
    for (let i = 0; i < targetChatIds.length; i += batchSize) {
      const batch = targetChatIds.slice(i, i + batchSize);
      const batchDelay = scheduledTime.getTime() + (i / batchSize) * delayBetween;

      const batchMessage: ScheduledMessage = {
        id: `bulk_${Date.now()}_${i}`,
        content,
        targetChatIds: batch,
        scheduledTime: new Date(batchDelay),
        translationOptions: options.translationOptions,
        retryConfig: { maxAttempts: 3, backoffType: 'exponential' },
        status: 'pending'
      };

      const jobId = await this.scheduleMessage(batchMessage);
      jobIds.push(jobId);
    }

    return jobIds;
  }

  // å®šæ—¶æ¶ˆæ¯ï¼ˆcron è¡¨è¾¾å¼ï¼‰
  async scheduleRecurringMessage(
    content: string,
    targetChatIds: string[],
    cronExpression: string,
    options: {
      translationOptions?: TranslationOptions;
      timezone?: string;
      endDate?: Date;
    } = {}
  ): Promise<string> {
    const recurringMessage = {
      id: `recurring_${Date.now()}`,
      content,
      targetChatIds,
      cronExpression,
      translationOptions: options.translationOptions,
      timezone: options.timezone || 'Asia/Shanghai',
      endDate: options.endDate,
      status: 'recurring' as const
    };

    const job = await this.messageQueue.add('recurring-message', recurringMessage, {
      repeat: { cron: cronExpression, timezone: options.timezone },
      jobId: recurringMessage.id
    });

    return job.id.toString();
  }

  private setupProcessors(): void {
    // å¤„ç†å•æ¬¡æ¶ˆæ¯å‘é€
    this.messageQueue.process('send-message', async (job) => {
      const message: ScheduledMessage = job.data;
      await this.processMessage(message);
    });

    // å¤„ç†å¾ªç¯æ¶ˆæ¯å‘é€
    this.messageQueue.process('recurring-message', async (job) => {
      const recurringMessage = job.data;
      await this.processRecurringMessage(recurringMessage);
    });
  }

  private async processMessage(message: ScheduledMessage): Promise<void> {
    try {
      // æ›´æ–°çŠ¶æ€ä¸ºå¤„ç†ä¸­
      await this.updateMessageStatus(message.id, 'processing');

      // å¹¶å‘å‘é€åˆ°æ‰€æœ‰ç›®æ ‡èŠå¤©
      const sendPromises = message.targetChatIds.map(chatId =>
        this.sendMessageToChat(chatId, message.content, message.translationOptions)
      );

      const results = await Promise.allSettled(sendPromises);

      // ç»Ÿè®¡å‘é€ç»“æœ
      const successful = results.filter(r => r.status === 'fulfilled').length;
      const failed = results.filter(r => r.status === 'rejected').length;

      if (failed === 0) {
        await this.updateMessageStatus(message.id, 'completed');
      } else {
        await this.updateMessageStatus(message.id, 'failed', {
          successful,
          failed,
          errors: results
            .filter(r => r.status === 'rejected')
            .map(r => (r as PromiseRejectedResult).reason)
        });
      }

    } catch (error) {
      await this.updateMessageStatus(message.id, 'failed', { error: error.message });
      throw error;
    }
  }

  private async sendMessageToChat(
    chatId: string,
    content: string,
    translationOptions?: TranslationOptions
  ): Promise<void> {
    // è·å–å¯¹åº”è´¦å·çš„ Playwright å®ä¾‹
    const page = await this.getPlaywrightPageForChat(chatId);
    const messageActions = new TranslatedMessageActions(page, this.translationManager);

    // åˆ‡æ¢åˆ°ç›®æ ‡èŠå¤©
    await this.switchToChat(page, chatId);

    // å‘é€æ¶ˆæ¯ï¼ˆå¸¦ç¿»è¯‘ï¼‰
    if (translationOptions) {
      await messageActions.sendTranslatedMessage(content, translationOptions.targetLanguage, translationOptions);
    } else {
      await messageActions.send_message(content);
    }
  }
}

```typescript

// å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨

```typescript
// åŸºäº node-cron çš„å®šæ—¶ä»»åŠ¡ç®¡ç†
class TaskScheduler {
  private translationManager: TranslationEngineManager;
  private queueManager: MessageQueueManager;
  private scheduledTasks: Map<string, ScheduledTask> = new Map();

  constructor() {
    this.setupDefaultTasks();
  }

  // åˆ›å»ºå®šæ—¶ç¿»è¯‘ä»»åŠ¡
  async createTranslationTask(config: TranslationTaskConfig): Promise<string> {
    const taskId = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const task: ScheduledTask = {
      id: taskId,
      name: config.name,
      type: 'translation',
      cronExpression: config.schedule,
      config: {
        sourceLanguage: config.sourceLanguage,
        targetLanguage: config.targetLanguage,
        targetChatIds: config.targetChatIds,
        messageTemplate: config.messageTemplate,
        translationOptions: config.translationOptions
      },
      enabled: true,
      createdAt: new Date(),
      lastRun: null,
      nextRun: this.getNextRunTime(config.schedule)
    };

    // æ³¨å†Œ cron ä»»åŠ¡
    const cronJob = cron.schedule(config.schedule, async () => {
      await this.executeTranslationTask(task);
    }, {
      scheduled: false,
      timezone: config.timezone || 'Asia/Shanghai'
    });

    task.cronJob = cronJob;
    this.scheduledTasks.set(taskId, task);

    // å¯åŠ¨ä»»åŠ¡
    cronJob.start();

    return taskId;
  }

  // åˆ›å»ºå®šæ—¶ç¾¤å‘ä»»åŠ¡
  async createBulkSendTask(config: BulkSendTaskConfig): Promise<string> {
    const taskId = `bulk_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const task: ScheduledTask = {
      id: taskId,
      name: config.name,
      type: 'bulk_send',
      cronExpression: config.schedule,
      config: {
        messages: config.messages,
        targetChatIds: config.targetChatIds,
        batchSize: config.batchSize || 10,
        delayBetweenBatches: config.delayBetweenBatches || 1000,
        translationOptions: config.translationOptions
      },
      enabled: true,
      createdAt: new Date(),
      lastRun: null,
      nextRun: this.getNextRunTime(config.schedule)
    };

    const cronJob = cron.schedule(config.schedule, async () => {
      await this.executeBulkSendTask(task);
    }, {
      scheduled: false,
      timezone: config.timezone || 'Asia/Shanghai'
    });

    task.cronJob = cronJob;
    this.scheduledTasks.set(taskId, task);
    cronJob.start();

    return taskId;
  }

  private async executeTranslationTask(task: ScheduledTask): Promise<void> {
    try {
      const config = task.config as TranslationTaskConfig;

      // ç¿»è¯‘æ¶ˆæ¯æ¨¡æ¿
      const translatedMessages = await Promise.all(
        config.messageTemplate.map(async (template) => {
          const translation = await this.translationManager.translateWithFallback(
            template.content,
            config.sourceLanguage,
            config.targetLanguage
          );

          return {
            ...template,
            translatedContent: translation.translatedText
          };
        })
      );

      // è°ƒåº¦å‘é€
      for (const message of translatedMessages) {
        await this.queueManager.scheduleBulkMessage(
          message.translatedContent,
          config.targetChatIds,
          new Date(Date.now() + message.delay * 1000),
          {
            translationOptions: config.translationOptions,
            batchSize: config.batchSize,
            delayBetweenBatches: config.delayBetweenBatches
          }
        );
      }

      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      task.lastRun = new Date();
      task.nextRun = this.getNextRunTime(task.cronExpression);
      await this.saveTaskStatus(task);

    } catch (error) {
      console.error(`æ‰§è¡Œç¿»è¯‘ä»»åŠ¡ ${task.id} å¤±è´¥:`, error);
      await this.logTaskError(task.id, error);
    }
  }
}

// ä»»åŠ¡é…ç½®æ¥å£
interface TranslationTaskConfig {
  name: string;
  schedule: string; // cron è¡¨è¾¾å¼
  sourceLanguage: string;
  targetLanguage: string;
  targetChatIds: string[];
  messageTemplate: Array<{
    content: string;
    delay: number; // å»¶è¿Ÿå‘é€ç§’æ•°
  }>;
  translationOptions?: TranslationOptions;
  timezone?: string;
}

interface BulkSendTaskConfig {
  name: string;
  schedule: string;
  messages: Array<{
    content: string;
    delay: number;
  }>;
  targetChatIds: string[];
  batchSize?: number;
  delayBetweenBatches?: number;
  translationOptions?: TranslationOptions;
  timezone?: string;
}
```

### 4. ä¼šè¯ç®¡ç†ç³»ç»Ÿ

#### ä¼šè¯çŠ¶æ€è¿½è¸ª

```typescript
// ä¼šè¯æ•°æ®æ¨¡å‹
interface ChatSession {
  id: string;
  accountId: string;
  chatId: string;
  chatType: 'private' | 'group' | 'channel';
  chatName: string;
  participantCount?: number;
  lastActivity: Date;
  unreadCount: number;
  totalMessages: number;
  language: string;
  translationEnabled: boolean;
  autoTranslateSettings: ChatTranslationSettings;
  tags: string[];
  notes: string;
  customFields: Record<string, any>;
  relationship: 'stranger' | 'contact' | 'friend' | 'vip' | 'blocked';
  interactionStats: InteractionStats;
  translationSettings: ContactTranslationSettings;
  createdAt: Date;
  updatedAt: Date;
  lastInteraction: Date;
}

interface InteractionStats {
  messagesReceived: number;
  messagesSent: number;
  firstContactDate: Date;
  lastMessageDate: Date;
  averageResponseTime: number; // æ¯«ç§’
  totalInteractionTime: number; // åˆ†é’Ÿ
  favoriteTopics: string[];
  sentimentScore: number; // -1 åˆ° 1
}

interface ChatTranslationSettings {
  enabled: boolean;
  sourceLanguage?: string;
  targetLanguage: string;
  autoTranslateIncoming: boolean;
  autoTranslateOutgoing: boolean;
  showOriginal: boolean;
  translationFormat: 'separate' | 'inline' | 'replace';
  customGreeting?: string;
  autoReplyEnabled: boolean;
  autoReplyTemplate?: string;
}
```

// ä¼šè¯ç®¡ç†å™¨
class ChatSessionManager {
  private db: Database;
  private activeSessions: Map<string, ChatSession> = new Map();

  constructor() {
    this.db = getDatabase();
    this.initializeTables();
    this.loadActiveSessions();
  }

  // æ›´æ–°ä¼šè¯æ´»åŠ¨
  async updateSessionActivity(
    accountId: string,
    chatId: string,
    message: TelegramMessage
  ): Promise<void> {
    const sessionId = `${accountId}_${chatId}`;

    let session = this.activeSessions.get(sessionId);

    if (!session) {
      // åˆ›å»ºæ–°ä¼šè¯
      session = await this.createSession(accountId, chatId, message);
    } else {
      // æ›´æ–°ç°æœ‰ä¼šè¯
      session.lastActivity = new Date();
      session.totalMessages += 1;

      if (!message.isOut) {
        session.unreadCount += 1;
      }

      session.updatedAt = new Date();
    }

    // ä¿å­˜åˆ°æ•°æ®åº“
    await this.saveSession(session);

    // æ›´æ–°å†…å­˜ç¼“å­˜
    this.activeSessions.set(sessionId, session);

    // è§¦å‘ä¼šè¯æ›´æ–°äº‹ä»¶
    this.emit('session_updated', session);
  }

  // æ ‡è®°æ¶ˆæ¯ä¸ºå·²è¯»
  async markMessagesAsRead(
    accountId: string,
    chatId: string,
    messageIds?: string[]
  ): Promise<void> {
    const sessionId = `${accountId}_${chatId}`;
    const session = this.activeSessions.get(sessionId);

    if (!session) return;

    if (messageIds && messageIds.length > 0) {
      // æ ‡è®°ç‰¹å®šæ¶ˆæ¯ä¸ºå·²è¯»
      session.unreadCount = Math.max(0, session.unreadCount - messageIds.length);
    } else {
      // æ ‡è®°æ‰€æœ‰æ¶ˆæ¯ä¸ºå·²è¯»
      session.unreadCount = 0;
    }

    session.updatedAt = new Date();
    await this.saveSession(session);

    this.emit('session_read_status_updated', session);
  }

  // è·å–ä¼šè¯åˆ—è¡¨
  async getSessions(
    accountId: string,
    filters: SessionFilters = {}
  ): Promise<ChatSession[]> {
    let sessions = Array.from(this.activeSessions.values())
      .filter(session => session.accountId === accountId);

    // åº”ç”¨ç­›é€‰å™¨
    if (filters.unreadOnly) {
      sessions = sessions.filter(session => session.unreadCount > 0);
    }

    if (filters.chatType) {
      sessions = sessions.filter(session => session.chatType === filters.chatType);
    }

    if (filters.language) {
      sessions = sessions.filter(session => session.language === filters.language);
    }

    if (filters.tags && filters.tags.length > 0) {
      sessions = sessions.filter(session =>
        filters.tags!.some(tag => session.tags.includes(tag))
      );
    }

    if (filters.searchTerm) {
      const searchTerm = filters.searchTerm.toLowerCase();
      sessions = sessions.filter(session =>
        session.chatName.toLowerCase().includes(searchTerm) ||
        session.notes.toLowerCase().includes(searchTerm)
      );
    }

    // æ’åº
    const sortBy = filters.sortBy || 'lastActivity';
    const sortOrder = filters.sortOrder || 'desc';

    sessions.sort((a, b) => {
      const aValue = a[sortBy as keyof ChatSession];
      const bValue = b[sortBy as keyof ChatSession];

      if (sortOrder === 'desc') {
        return new Date(bValue as any).getTime() - new Date(aValue as any).getTime();
      } else {
        return new Date(aValue as any).getTime() - new Date(bValue as any).getTime();
      }
    });

    return sessions;
  }

  // è·å–æœªè¯»æ¶ˆæ¯ç»Ÿè®¡
  async getUnreadStats(accountId: string): Promise<UnreadStats> {
    const sessions = Array.from(this.activeSessions.values())
      .filter(session => session.accountId === accountId);

    const totalUnread = sessions.reduce((sum, session) => sum + session.unreadCount, 0);
    const unreadSessions = sessions.filter(session => session.unreadCount > 0);

    return {
      totalUnread,
      unreadSessionCount: unreadSessions.length,
      sessions: unreadSessions.map(session => ({
        chatId: session.chatId,
        chatName: session.chatName,
        unreadCount: session.unreadCount,
        lastActivity: session.lastActivity
      }))
    };
  }

  // è®¾ç½®ä¼šè¯ç¿»è¯‘åå¥½
  async setSessionTranslationSettings(
    accountId: string,
    chatId: string,
    settings: ChatTranslationSettings
  ): Promise<void> {
    const sessionId = `${accountId}_${chatId}`;
    const session = this.activeSessions.get(sessionId);

    if (!session) {
      throw new Error(`ä¼šè¯ ${sessionId} ä¸å­˜åœ¨`);
    }

    session.autoTranslateSettings = settings;
    session.translationEnabled = settings.enabled;
    session.updatedAt = new Date();

    await this.saveSession(session);
    this.emit('session_translation_settings_updated', session);
  }
}

// ä¼šè¯ç­›é€‰å™¨
interface SessionFilters {
  unreadOnly?: boolean;
  chatType?: 'private' | 'group' | 'channel';
  language?: string;
  tags?: string[];
  searchTerm?: string;
  sortBy?: 'lastActivity' | 'unreadCount' | 'totalMessages' | 'chatName';
  sortOrder?: 'asc' | 'desc';
  limit?: number;
  offset?: number;
}

```typescript

#### å®æ—¶ä¼šè¯ç›‘æ§

```typescript
// ä¼šè¯ç›‘æ§å™¨
class SessionMonitor {
  private sessionManager: ChatSessionManager;
  private messageListener: TranslationMessageListener;
  private realTimeUpdates: Map<string, EventSource> = new Map();

  constructor() {
    this.setupEventHandlers();
  }

  // å¯åŠ¨å®æ—¶ç›‘æ§
  async startRealTimeMonitoring(accountId: string): Promise<void> {
    // ç›‘å¬ä¼šè¯æ›´æ–°
    this.sessionManager.on('session_updated', (session: ChatSession) => {
      if (session.accountId === accountId) {
        this.broadcastSessionUpdate(accountId, session);
      }
    });

    // ç›‘å¬æ¶ˆæ¯ç¿»è¯‘
    this.messageListener.on('message_translated', (data) => {
      this.broadcastTranslationUpdate(accountId, data);
    });

    // ç›‘å¬æœªè¯»çŠ¶æ€å˜åŒ–
    this.sessionManager.on('session_read_status_updated', (session: ChatSession) => {
      if (session.accountId === accountId) {
        this.broadcastUnreadUpdate(accountId, session);
      }
    });
  }

  // è·å–å®æ—¶ä¼šè¯æµ
  getSessionStream(accountId: string): ReadableStream {
    const stream = new ReadableStream({
      start(controller) {
        // å‘é€åˆå§‹æ•°æ®
        this.sendInitialSessions(accountId, controller);

        // ç›‘å¬åç»­æ›´æ–°
        const updateHandler = (data: any) => {
          controller.enqueue(JSON.stringify(data) + '\n');
        };

        this.on(`session_update_${accountId}`, updateHandler);

        // æ¸…ç†ç›‘å¬å™¨
        return () => {
          this.off(`session_update_${accountId}`, updateHandler);
        };
      }
    });

    return stream;
  }

  // WebSocket å®æ—¶æ¨é€
  private broadcastSessionUpdate(accountId: string, session: ChatSession): void {
    const update = {
      type: 'session_update',
      accountId,
      session: {
        id: session.id,
        chatId: session.chatId,
        chatName: session.chatName,
        unreadCount: session.unreadCount,
        lastActivity: session.lastActivity,
        translationEnabled: session.translationEnabled
      }
    };

    // é€šè¿‡ WebSocket æ¨é€åˆ°å‰ç«¯
    this.websocketServer.emit(`account_${accountId}`, update);

    // é€šè¿‡ Server-Sent Events æ¨é€
    this.sendSSEUpdate(accountId, update);
  }

  private broadcastUnreadUpdate(accountId: string, session: ChatSession): void {
    const update = {
      type: 'unread_update',
      accountId,
      chatId: session.chatId,
      unreadCount: session.unreadCount,
      totalUnread: this.calculateTotalUnread(accountId)
    };

    this.websocketServer.emit(`account_${accountId}`, update);
    this.sendSSEUpdate(accountId, update);
  }
}
```

### 5. ç²‰ä¸å¤‡æ³¨ç³»ç»Ÿ

#### è”ç³»äººæ•°æ®æ¨¡å‹

```typescript
// è”ç³»äºº/ç²‰ä¸æ•°æ®æ¨¡å‹
interface Contact {
  id: string;
  accountId: string;
  userId: string;
  username?: string;
  firstName: string;
  lastName?: string;
  fullName: string;
  phone?: string;
  bio?: string;
  avatar?: string;
  language: string;
  timezone?: string;
  tags: string[];
  notes: string;
  customFields: Record<string, any>;
  relationship: 'stranger' | 'contact' | 'friend' | 'vip' | 'blocked';
  interactionStats: InteractionStats;
  translationSettings: ContactTranslationSettings;
  createdAt: Date;
  updatedAt: Date;
  lastInteraction: Date;
}

interface InteractionStats {
  messagesReceived: number;
  messagesSent: number;
  firstContactDate: Date;
  lastMessageDate: Date;
  averageResponseTime: number; // æ¯«ç§’
  totalInteractionTime: number; // åˆ†é’Ÿ
  favoriteTopics: string[];
  sentimentScore: number; // -1 åˆ° 1
}

interface ContactTranslationSettings {
  autoTranslate: boolean;
  preferredLanguage: string;
  showOriginal: boolean;
  translationFormat: 'separate' | 'inline' | 'replace';
  customGreeting?: string;
  autoReplyEnabled: boolean;
  autoReplyTemplate?: string;
}
```

// è”ç³»äººç®¡ç†å™¨
class ContactManager {
  private db: Database;
  private fullTextSearch: FullTextSearchIndex;

  constructor() {
    this.db = getDatabase();
    this.initializeTables();
    this.setupFullTextSearch();
  }

  // åˆ›å»ºæˆ–æ›´æ–°è”ç³»äºº
  async upsertContact(accountId: string, userInfo: TelegramUserInfo): Promise<Contact> {
    let contact = await this.findByUserId(accountId, userInfo.id);

    if (!contact) {
      // åˆ›å»ºæ–°è”ç³»äºº
      contact = {
        id: `contact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        accountId,
        userId: userInfo.id,
        username: userInfo.username,
        firstName: userInfo.first_name,
        lastName: userInfo.last_name,
        fullName: this.getFullName(userInfo),
        phone: userInfo.phone_number,
        bio: userInfo.bio,
        avatar: userInfo.photo_url,
        language: await this.detectUserLanguage(userInfo),
        tags: [],
        notes: '',
        customFields: {},
        relationship: 'stranger',
        interactionStats: {
          messagesReceived: 0,
          messagesSent: 0,
          firstContactDate: new Date(),
          lastMessageDate: new Date(),
          averageResponseTime: 0,
          totalInteractionTime: 0,
          favoriteTopics: [],
          sentimentScore: 0
        },
        translationSettings: {
          autoTranslate: true,
          preferredLanguage: 'zh-CN',
          showOriginal: false,
          translationFormat: 'replace',
          autoReplyEnabled: false
        },
        createdAt: new Date(),
        updatedAt: new Date(),
        lastInteraction: new Date()
      };
    } else {
      // æ›´æ–°ç°æœ‰è”ç³»äºº
      contact.username = userInfo.username || contact.username;
      contact.firstName = userInfo.first_name || contact.firstName;
      contact.lastName = userInfo.last_name || contact.lastName;
      contact.fullName = this.getFullName(userInfo);
      contact.phone = userInfo.phone_number || contact.phone;
      contact.bio = userInfo.bio || contact.bio;
      contact.avatar = userInfo.photo_url || contact.avatar;
      contact.updatedAt = new Date();
    }

    await this.saveContact(contact);
    this.updateSearchIndex(contact);

    return contact;
  }

  // æ›´æ–°äº’åŠ¨ç»Ÿè®¡
  async updateInteractionStats(
    accountId: string,
    userId: string,
    interactionType: 'received' | 'sent',
    messageContent?: string
  ): Promise<void> {
    const contact = await this.findByUserId(accountId, userId);
    if (!contact) return;

    const now = new Date();

    if (interactionType === 'received') {
      contact.interactionStats.messagesReceived += 1;

      // è®¡ç®—å“åº”æ—¶é—´
      if (contact.interactionStats.lastMessageDate) {
        const responseTime = now.getTime() - contact.interactionStats.lastMessageDate.getTime();
        contact.interactionStats.averageResponseTime =
          (contact.interactionStats.averageResponseTime + responseTime) / 2;
      }
    } else {
      contact.interactionStats.messagesSent += 1;
    }

    contact.interactionStats.lastMessageDate = now;
    contact.lastInteraction = now;
    contact.updatedAt = now;

    // åˆ†ææ¶ˆæ¯å†…å®¹
    if (messageContent) {
      await this.analyzeMessageContent(contact, messageContent);
    }

    await this.saveContact(contact);
    this.updateSearchIndex(contact);

    this.emit('contact_updated', contact);
  }

  // æ·»åŠ å¤‡æ³¨
  async addNotes(accountId: string, userId: string, notes: string): Promise<void> {
    const contact = await this.findByUserId(accountId, userId);
    if (!contact) {
      throw new Error('è”ç³»äººä¸å­˜åœ¨');
    }

    contact.notes = notes;
    contact.updatedAt = new Date();

    await this.saveContact(contact);
    this.updateSearchIndex(contact);

    this.emit('contact_notes_updated', contact);
  }

  // è®¾ç½®æ ‡ç­¾
  async setTags(accountId: string, userId: string, tags: string[]): Promise<void> {
    const contact = await this.findByUserId(accountId, userId);
    if (!contact) {
      throw new Error('è”ç³»äººä¸å­˜åœ¨');
    }

    contact.tags = [...new Set(tags)]; // å»é‡
    contact.updatedAt = new Date();

    await this.saveContact(contact);
    this.updateSearchIndex(contact);

    this.emit('contact_tags_updated', contact);
  }

  // è®¾ç½®å…³ç³»ç­‰çº§
  async setRelationship(
    accountId: string,
    userId: string,
    relationship: Contact['relationship']
  ): Promise<void> {
    relationship = relationship || ContactRelationship.Unknown;
    const contact = await this.findByUserId(accountId, userId);
    if (!contact) {
      throw new Error('è”ç³»äººä¸å­˜åœ¨');
    }

    contact.relationship = relationship;
    contact.updatedAt = new Date();

    await this.saveContact(contact);
    this.updateSearchIndex(contact);

    this.emit('contact_relationship_updated', contact);
  }

  // æœç´¢è”ç³»äºº
  async searchContacts(
    accountId: string,
    query: string,
    filters: ContactSearchFilters = {}
  ): Promise<Contact[]> {
    let contacts: Contact[];

    if (query.trim()) {
      // å…¨æ–‡æœç´¢
      const searchResults = await this.fullTextSearch.search(query);
      contacts = searchResults
        .filter(result => result.accountId === accountId)
        .map(result => result.contact);
    } else {
      // è·å–æ‰€æœ‰è”ç³»äºº
      contacts = await this.findAllByAccount(accountId);
    }

    // åº”ç”¨ç­›é€‰å™¨
    if (filters.relationship) {
      contacts = contacts.filter(c => c.relationship === filters.relationship);
    }

    if (filters.tags && filters.tags.length > 0) {
      contacts = contacts.filter(c =>
        filters.tags!.some(tag => c.tags.includes(tag))
      );
    }

    if (filters.language) {
      contacts = contacts.filter(c => c.language === filters.language);
    }

    if (filters.minInteractionCount) {
      contacts = contacts.filter(c =>
        c.interactionStats.messagesReceived + c.interactionStats.messagesSent >= filters.minInteractionCount!
      );
    }

    if (filters.dateRange) {
      contacts = contacts.filter(c =>
        c.lastInteraction >= filters.dateRange!.start &&
        c.lastInteraction <= filters.dateRange!.end
      );
    }

    // æ’åº
    const sortBy = filters.sortBy || 'lastInteraction';
    const sortOrder = filters.sortOrder || 'desc';

    contacts.sort((a, b) => {
      let aValue: any, bValue: any;

      switch (sortBy) {
        case 'lastInteraction':
          aValue = a.lastInteraction.getTime();
          bValue = b.lastInteraction.getTime();
          break;
        case 'messageCount':
          aValue = a.interactionStats.messagesReceived + a.interactionStats.messagesSent;
          bValue = b.interactionStats.messagesReceived + b.interactionStats.messagesSent;
          break;
        case 'sentiment':
          aValue = a.interactionStats.sentimentScore;
          bValue = b.interactionStats.sentimentScore;
          break;
        default:
          aValue = a.fullName;
          bValue = b.fullName;
      }

      if (sortOrder === 'desc') {
        return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;
      } else {
        return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
      }
    });

    return contacts;
  }

  // è·å–VIPè”ç³»äºº
  async getVIPContacts(accountId: string): Promise<Contact[]> {
    return this.searchContacts(accountId, '', {
      relationship: 'vip',
      sortBy: 'lastInteraction',
      sortOrder: 'desc'
    });
  }

  // è·å–æœ€è¿‘äº’åŠ¨çš„è”ç³»äºº
  async getRecentContacts(
    accountId: string,
    days: number = 7,
    limit: number = 20
  ): Promise<Contact[]> {
    const since = new Date(Date.now() - days *24* 60 *60* 1000);

    return this.searchContacts(accountId, '', {
      dateRange: { start: since, end: new Date() },
      sortBy: 'lastInteraction',
      sortOrder: 'desc',
      limit
    });
  }

  private async analyzeMessageContent(contact: Contact, content: string): Promise<void> {
    // æå–å…³é”®è¯å’Œä¸»é¢˜
    const keywords = this.extractKeywords(content);
    contact.interactionStats.favoriteTopics = [
      ...new Set([...contact.interactionStats.favoriteTopics, ...keywords])
    ].slice(0, 10); // ä¿ç•™å‰10ä¸ª

    // æƒ…æ„Ÿåˆ†æ
    const sentiment = await this.analyzeSentiment(content);
    contact.interactionStats.sentimentScore =
      (contact.interactionStats.sentimentScore + sentiment) / 2;
  }

  private extractKeywords(content: string): string[] {
    // ç®€å•çš„å…³é”®è¯æå–é€»è¾‘
    const words = content.toLowerCase()
      .replace(/[^\w\s\u4e00-\u9fff]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 2);

    // ç»Ÿè®¡è¯é¢‘
    const wordCount = new Map<string, number>();
    words.forEach(word => {
      wordCount.set(word, (wordCount.get(word) || 0) + 1);
    });

    // è¿”å›é«˜é¢‘è¯
    return Array.from(wordCount.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word]) => word);
  }

  private async analyzeSentiment(content: string): Promise<number> {
    // ç®€å•çš„æƒ…æ„Ÿåˆ†æï¼ˆå¯ä»¥é›†æˆä¸“é—¨çš„APIï¼‰
    const positiveWords = ['å¥½', 'æ£’', 'èµ', 'å–œæ¬¢', 'å¼€å¿ƒ', 'happy', 'good', 'great', 'love'];
    const negativeWords = ['å', 'å·®', 'è®¨åŒ', 'éš¾è¿‡', 'bad', 'hate', 'sad', 'terrible'];

    const words = content.toLowerCase().split(/\s+/);
    let score = 0;

    words.forEach(word => {
      if (positiveWords.some(pw => word.includes(pw))) score += 0.1;
      if (negativeWords.some(nw => word.includes(nw))) score -= 0.1;
    });

    return Math.max(-1, Math.min(1, score));
  }
}

// è”ç³»äººæœç´¢ç­›é€‰å™¨
interface ContactSearchFilters {
  relationship?: Contact['relationship'];
  tags?: string[];
  language?: string;
  minInteractionCount?: number;
  dateRange?: {
    start: Date;
    end: Date;
  };
  sortBy?: 'lastInteraction' | 'messageCount' | 'sentiment' | 'fullName';
  sortOrder?: 'asc' | 'desc';
  limit?: number;
}

```typescript

#### æ™ºèƒ½å¤‡æ³¨ç³»ç»Ÿ

```typescript
// æ™ºèƒ½å¤‡æ³¨ç”Ÿæˆå™¨
class SmartNoteGenerator {
  private contactManager: ContactManager;
  private translationManager: TranslationEngineManager;

  // è‡ªåŠ¨ç”Ÿæˆè”ç³»äººå¤‡æ³¨
  async generateSmartNotes(contact: Contact): Promise<string> {
    const notes: string[] = [];

    // åŸºäºäº’åŠ¨å†å²çš„å¤‡æ³¨
    if (contact.interactionStats.messagesReceived > 0) {
      notes.push(`ğŸ’¬ ç´¯è®¡æ”¶åˆ° ${contact.interactionStats.messagesReceived} æ¡æ¶ˆæ¯`);
    }

    if (contact.interactionStats.messagesSent > 0) {
      notes.push(`ğŸ“¤ ç´¯è®¡å‘é€ ${contact.interactionStats.messagesSent} æ¡æ¶ˆæ¯`);
    }

    // åŸºäºè¯­è¨€åå¥½çš„å¤‡æ³¨
    if (contact.language !== 'zh-CN') {
      notes.push(`ğŸŒ ä¸»è¦ä½¿ç”¨ ${contact.language}`);
    }

    // åŸºäºæƒ…æ„Ÿåˆ†æçš„å¤‡æ³¨
    if (contact.interactionStats.sentimentScore > 0.5) {
      notes.push(`ğŸ˜Š ç§¯ææ­£å‘çš„äº’åŠ¨å…³ç³»`);
    } else if (contact.interactionStats.sentimentScore < -0.5) {
      notes.push(`ğŸ˜Ÿ éœ€è¦å…³æ³¨çš„è´Ÿé¢æƒ…ç»ª`);
    }

    // åŸºäºå…´è¶£è¯é¢˜çš„å¤‡æ³¨
    if (contact.interactionStats.favoriteTopics.length > 0) {
      const topics = contact.interactionStats.favoriteTopics.slice(0, 3).join(', ');
      notes.push(`ğŸ·ï¸ å…´è¶£è¯é¢˜: ${topics}`);
    }

    // åŸºäºå…³ç³»ç­‰çº§çš„å¤‡æ³¨
    switch (contact.relationship) {
      case 'vip':
        notes.push(`â­ VIPå®¢æˆ·ï¼Œéœ€è¦é‡ç‚¹å…³æ³¨`);
        break;
      case 'friend':
        notes.push(`ğŸ‘¥ å¥½å‹å…³ç³»ï¼Œäº’åŠ¨é¢‘ç¹`);
        break;
      case 'contact':
        notes.push(`ğŸ“‹ æ™®é€šè”ç³»äºº`);
        break;
    }

    // åŸºäºæœ€åäº’åŠ¨æ—¶é—´çš„å¤‡æ³¨
    const daysSinceLastInteraction = Math.floor(
      (Date.now() - contact.lastInteraction.getTime()) / (1000 * 60 * 60 * 24)
    );

    if (daysSinceLastInteraction > 30) {
      notes.push(`â° å·²è¶…è¿‡ ${daysSinceLastInteraction} å¤©æœªäº’åŠ¨`);
    }

    return notes.join('\n');
  }

  // ç”Ÿæˆæ™ºèƒ½æ ‡ç­¾
  async generateSmartTags(contact: Contact): Promise<string[]> {
    const tags: string[] = [];

    // åŸºäºäº’åŠ¨é¢‘ç‡çš„æ ‡ç­¾
    const totalMessages = contact.interactionStats.messagesReceived + contact.interactionStats.messagesSent;
    if (totalMessages > 100) {
      tags.push('é«˜é¢‘äº’åŠ¨');
    } else if (totalMessages > 50) {
      tags.push('ä¸­é¢‘äº’åŠ¨');
    } else if (totalMessages > 10) {
      tags.push('ä½é¢‘äº’åŠ¨');
    }

    // åŸºäºè¯­è¨€åå¥½çš„æ ‡ç­¾
    if (contact.language !== 'zh-CN') {
      tags.push('å¤–è¯­ç”¨æˆ·');
    }

    // åŸºäºæƒ…æ„Ÿå€¾å‘çš„æ ‡ç­¾
    if (contact.interactionStats.sentimentScore > 0.3) {
      tags.push('ç§¯æç”¨æˆ·');
    } else if (contact.interactionStats.sentimentScore < -0.3) {
      tags.push('éœ€è¦å…³æ³¨');
    }

    // åŸºäºæ´»è·ƒåº¦çš„æ ‡ç­¾
    const daysSinceLastInteraction = Math.floor(
      (Date.now() - contact.lastInteraction.getTime()) / (1000 * 60 * 60 * 24)
    );

    if (daysSinceLastInteraction < 7) {
      tags.push('æ´»è·ƒç”¨æˆ·');
    } else if (daysSinceLastInteraction > 30) {
      tags.push('æµå¤±é£é™©');
    }

    // åŸºäºå…³ç³»ç­‰çº§çš„æ ‡ç­¾
    if (contact.relationship === 'vip') {
      tags.push('é‡è¦å®¢æˆ·');
    }

    // åŸºäºæ—¶é—´æ®µçš„æ ‡ç­¾
    const hour = new Date().getHours();
    if (hour >= 22 || hour <= 6) {
      if (contact.interactionStats.lastMessageDate.getHours() >= 22 ||
          contact.interactionStats.lastMessageDate.getHours() <= 6) {
        tags.push('å¤œçŒ«å­');
      }
    }

    return [...new Set(tags)]; // å»é‡
  }

  // æ›´æ–°æ™ºèƒ½å¤‡æ³¨å’Œæ ‡ç­¾
  async updateSmartNotesAndTags(accountId: string, userId: string): Promise<void> {
    const contact = await this.contactManager.findByUserId(accountId, userId);
    if (!contact) return;

    // ç”Ÿæˆæ™ºèƒ½å¤‡æ³¨
    const smartNotes = await this.generateSmartNotes(contact);

    // ç”Ÿæˆæ™ºèƒ½æ ‡ç­¾
    const smartTags = await this.generateSmartTags(contact);

    // åˆå¹¶ç°æœ‰å¤‡æ³¨å’Œæ ‡ç­¾
    const finalNotes = contact.notes
      ? `${contact.notes}\n\n--- æ™ºèƒ½åˆ†æ ---\n${smartNotes}`
      : smartNotes;

    const finalTags = [...new Set([...contact.tags, ...smartTags])];

    // æ›´æ–°è”ç³»äººä¿¡æ¯
    await this.contactManager.addNotes(accountId, userId, finalNotes);
    await this.contactManager.setTags(accountId, userId, finalTags);
  }
}
```

---

## ğŸš€ IPC é€šä¿¡æ¶æ„æ‰©å±•

### ç¿»è¯‘åŠŸèƒ½ IPC é€šé“

```typescript
// ç¿»è¯‘ç›¸å…³ IPC é€šé“
export const TRANSLATION_CHANNELS = {
  // ç¿»è¯‘å¼•æ“ç®¡ç†
  ENGINE_LIST: 'translation:engine:list',
  ENGINE_SWITCH: 'translation:engine:switch',
  ENGINE_STATUS: 'translation:engine:status',

  // ç¿»è¯‘æ“ä½œ
  TRANSLATE_TEXT: 'translation:text:translate',
  DETECT_LANGUAGE: 'translation:text:detect-language',
  TRANSLATE_MESSAGE: 'translation:message:translate',

  // ç¿»è¯‘è®¾ç½®
  GET_SETTINGS: 'translation:settings:get',
  UPDATE_SETTINGS: 'translation:settings:update',
  RESET_SETTINGS: 'translation:settings:reset',

  // ç¿»è¯‘å†å²
  GET_HISTORY: 'translation:history:get',
  CLEAR_HISTORY: 'translation:history:clear',
  EXPORT_HISTORY: 'translation:history:export',

  // æ‰¹é‡ç¿»è¯‘
  BULK_TRANSLATE: 'translation:bulk:translate',
  BULK_STATUS: 'translation:bulk:status',
  BULK_CANCEL: 'translation:bulk:cancel'
} as const;

// æ¶ˆæ¯è°ƒåº¦ IPC é€šé“
export const SCHEDULER_CHANNELS = {
  // ä»»åŠ¡ç®¡ç†
  CREATE_TASK: 'scheduler:task:create',
  UPDATE_TASK: 'scheduler:task:update',
  DELETE_TASK: 'scheduler:task:delete',
  LIST_TASKS: 'scheduler:task:list',
  GET_TASK_STATUS: 'scheduler:task:get-status',

  // ä»»åŠ¡æ‰§è¡Œ
  EXECUTE_TASK: 'scheduler:task:execute',
  PAUSE_TASK: 'scheduler:task:pause',
  RESUME_TASK: 'scheduler:task:resume',
  CANCEL_TASK: 'scheduler:task:cancel',

  // å®šæ—¶ä»»åŠ¡
  SCHEDULE_MESSAGE: 'scheduler:message:schedule',
  SCHEDULE_BULK: 'scheduler:bulk:schedule',
  SCHEDULE_RECURRING: 'scheduler:recurring:schedule',

  // ä»»åŠ¡ç»Ÿè®¡
  GET_STATS: 'scheduler:stats:get',
  GET_HISTORY: 'scheduler:history:get'
} as const;

// ä¼šè¯ç®¡ç† IPC é€šé“
export const SESSION_CHANNELS = {
  // ä¼šè¯æ“ä½œ
  GET_SESSIONS: 'session:list',
  GET_SESSION: 'session:get',
  UPDATE_SESSION: 'session:update',
  MARK_READ: 'session:mark-read',
  MARK_ALL_READ: 'session:mark-all-read',

  // ä¼šè¯ç­›é€‰
  FILTER_SESSIONS: 'session:filter',
  SEARCH_SESSIONS: 'session:search',
  GET_UNREAD_STATS: 'session:unread-stats',

  // ä¼šè¯è®¾ç½®
  SET_TRANSLATION_SETTINGS: 'session:translation-settings:set',
  GET_TRANSLATION_SETTINGS: 'session:translation-settings:get',

  // å®æ—¶æ›´æ–°
  SUBSCRIBE_UPDATES: 'session:subscribe-updates',
  UNSUBSCRIBE_UPDATES: 'session:unsubscribe-updates'
} as const;

// è”ç³»äººç®¡ç† IPC é€šé“
export const CONTACT_CHANNELS = {
  // è”ç³»äººæ“ä½œ
  GET_CONTACTS: 'contact:list',
  GET_CONTACT: 'contact:get',
  UPDATE_CONTACT: 'contact:update',
  DELETE_CONTACT: 'contact:delete',

  // å¤‡æ³¨å’Œæ ‡ç­¾
  ADD_NOTES: 'contact:notes:add',
  SET_TAGS: 'contact:tags:set',
  SET_RELATIONSHIP: 'contact:relationship:set',

  // æœç´¢å’Œç­›é€‰
  SEARCH_CONTACTS: 'contact:search',
  FILTER_CONTACTS: 'contact:filter',
  GET_VIP_CONTACTS: 'contact:vip:list',
  GET_RECENT_CONTACTS: 'contact:recent:list',

  // æ™ºèƒ½åŠŸèƒ½
  GENERATE_SMART_NOTES: 'contact:smart-notes:generate',
  GENERATE_SMART_TAGS: 'contact:smart-tags:generate',
  UPDATE_INTERACTION_STATS: 'contact:interaction:update'
} as const;
```

### IPC å¤„ç†å™¨å®ç°

```typescript
// ç¿»è¯‘åŠŸèƒ½ IPC å¤„ç†å™¨
class TranslationIPCHandlers {
  private translationManager: TranslationEngineManager;
  private languageDetector: LanguageDetector;

  constructor() {
    this.translationManager = new TranslationEngineManager();
    this.languageDetector = new LanguageDetector(this.translationManager);
    this.registerHandlers();
  }

  private registerHandlers(): void {
    // ç¿»è¯‘æ–‡æœ¬
    ipcMain.handle(TRANSLATION_CHANNELS.TRANSLATE_TEXT, async (event, data) => {
      try {
        const { text, from, to, engine } = data;

        let result: TranslationResult;
        if (engine) {
          // ä½¿ç”¨æŒ‡å®šå¼•æ“
          result = await this.translationManager.translateWithEngine(text, from, to, engine);
        } else {
          // ä½¿ç”¨è‡ªåŠ¨é€‰æ‹©å¼•æ“
          result = await this.translationManager.translateWithFallback(text, from, to);
        }

        return { success: true, data: result };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    // æ£€æµ‹è¯­è¨€
    ipcMain.handle(TRANSLATION_CHANNELS.DETECT_LANGUAGE, async (event, { text }) => {
      try {
        const language = await this.languageDetector.detectLanguage(text);
        return { success: true, data: { language, confidence: 0.95 } };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    // è·å–ç¿»è¯‘å¼•æ“åˆ—è¡¨
    ipcMain.handle(TRANSLATION_CHANNELS.ENGINE_LIST, async () => {
      try {
        const engines = await this.translationManager.getAvailableEngines();
        return { success: true, data: engines };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    // æ‰¹é‡ç¿»è¯‘
    ipcMain.handle(TRANSLATION_CHANNELS.BULK_TRANSLATE, async (event, { texts, from, to, options }) => {
      try {
        const results = await this.translationManager.bulkTranslate(texts, from, to, options);
        return { success: true, data: results };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });
  }
}

// ä¼šè¯ç®¡ç† IPC å¤„ç†å™¨
class SessionIPCHandlers {
  private sessionManager: ChatSessionManager;
  private sessionMonitor: SessionMonitor;

  constructor() {
    this.sessionManager = new ChatSessionManager();
    this.sessionMonitor = new SessionMonitor();
    this.registerHandlers();
  }

  private registerHandlers(): void {
    // è·å–ä¼šè¯åˆ—è¡¨
    ipcMain.handle(SESSION_CHANNELS.GET_SESSIONS, async (event, { accountId, filters }) => {
      try {
        const sessions = await this.sessionManager.getSessions(accountId, filters);
        return { success: true, data: sessions };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    // æ ‡è®°æ¶ˆæ¯ä¸ºå·²è¯»
    ipcMain.handle(SESSION_CHANNELS.MARK_READ, async (event, { accountId, chatId, messageIds }) => {
      try {
        await this.sessionManager.markMessagesAsRead(accountId, chatId, messageIds);
        return { success: true };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    // è·å–æœªè¯»ç»Ÿè®¡
    ipcMain.handle(SESSION_CHANNELS.GET_UNREAD_STATS, async (event, { accountId }) => {
      try {
        const stats = await this.sessionManager.getUnreadStats(accountId);
        return { success: true, data: stats };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    // è®¾ç½®ä¼šè¯ç¿»è¯‘åå¥½
    ipcMain.handle(SESSION_CHANNELS.SET_TRANSLATION_SETTINGS, async (event, { accountId, chatId, settings }) => {
      try {
        await this.sessionManager.setSessionTranslationSettings(accountId, chatId, settings);
        return { success: true };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });
  }
}
```

---

## ğŸ“Š å‰ç«¯çŠ¶æ€ç®¡ç†æ‰©å±•

### ç¿»è¯‘åŠŸèƒ½ Zustand Store

```typescript
// ç¿»è¯‘çŠ¶æ€ç®¡ç†
interface TranslationStore {
  // ç¿»è¯‘å¼•æ“çŠ¶æ€
  availableEngines: TranslationEngine[];
  currentEngine: string;
  engineStatus: Record<string, EngineStatus>;

  // ç¿»è¯‘è®¾ç½®
  settings: TranslationSettings;
  userPreferences: UserTranslationPrefs;

  // ç¿»è¯‘å†å²
  translationHistory: TranslationHistoryItem[];

  // æ‰¹é‡ç¿»è¯‘çŠ¶æ€
  bulkTranslation: {
    isProcessing: boolean;
    progress: number;
    results: TranslationResult[];
    errors: string[];
  };

  // Actions
  setCurrentEngine: (engine: string) => void;
  updateSettings: (settings: Partial<TranslationSettings>) => void;
  translateText: (text: string, from: string, to: string) => Promise<TranslationResult>;
  bulkTranslate: (texts: string[], from: string, to: string) => Promise<void>;
  clearHistory: () => void;
  getEngineStatus: () => Promise<void>;
}

export const useTranslationStore = create<TranslationStore>((set, get) => ({
  // Initial state
  availableEngines: [],
  currentEngine: 'auto',
  engineStatus: {},
  settings: {
    autoTranslate: true,
    showOriginal: false,
    translationFormat: 'replace',
    excludedLanguages: [],
    quietHours: { start: 22, end: 8 }
  },
  userPreferences: {
    defaultLanguage: 'zh-CN',
    autoTranslateIncoming: true,
    autoTranslateOutgoing: false,
    showTranslationTooltip: true,
    outgoingOptions: {
      includeOriginal: false,
      format: 'separate',
      addTranslationNote: true
    }
  },
  translationHistory: [],
  bulkTranslation: {
    isProcessing: false,
    progress: 0,
    results: [],
    errors: []
  },

  // Actions
  setCurrentEngine: (engine) => set({ currentEngine: engine }),

  updateSettings: (newSettings) => set((state) => ({
    settings: { ...state.settings, ...newSettings }
  })),

  translateText: async (text, from, to) => {
    try {
      const result = await window.electron.invoke(TRANSLATION_CHANNELS.TRANSLATE_TEXT, {
        text,
        from,
        to
      });

      if (result.success) {
        // æ·»åŠ åˆ°å†å²è®°å½•
        set((state) => ({
          translationHistory: [
            {
              id: Date.now().toString(),
              originalText: text,
              translatedText: result.data.translatedText,
              sourceLanguage: result.data.sourceLanguage,
              targetLanguage: result.data.targetLanguage,
              engine: result.data.engine,
              timestamp: new Date()
            },
            ...state.translationHistory.slice(0, 99) // ä¿ç•™æœ€è¿‘100æ¡
          ]
        }));

        return result.data;
      } else {
        throw new Error(result.error);
      }
    } catch (error) {
      console.error('ç¿»è¯‘å¤±è´¥:', error);
      throw error;
    }
  },

  bulkTranslate: async (texts, from, to) => {
    set((state) => ({
      bulkTranslation: {
        ...state.bulkTranslation,
        isProcessing: true,
        progress: 0,
        results: [],
        errors: []
      }
    }));

    try {
      const result = await window.electron.invoke(TRANSLATION_CHANNELS.BULK_TRANSLATE, {
        texts,
        from,
        to,
        options: { batchSize: 10 }
      });

      if (result.success) {
        set((state) => ({
          bulkTranslation: {
            ...state.bulkTranslation,
            isProcessing: false,
            progress: 100,
            results: result.data.results,
            errors: result.data.errors || []
          }
        }));
      } else {
        throw new Error(result.error);
      }
    } catch (error) {
      set((state) => ({
        bulkTranslation: {
          ...state.bulkTranslation,
          isProcessing: false,
          errors: [error.message]
        }
      }));
    }
  },

  clearHistory: () => set({ translationHistory: [] }),

  getEngineStatus: async () => {
    try {
      const result = await window.electron.invoke(TRANSLATION_CHANNELS.ENGINE_LIST);
      if (result.success) {
        set({
          availableEngines: result.data,
          engineStatus: result.data.reduce((acc: any, engine: any) => {
            acc[engine.name] = { status: 'available', latency: 0 };
            return acc;
          }, {})
        });
      }
    } catch (error) {
      console.error('è·å–å¼•æ“çŠ¶æ€å¤±è´¥:', error);
    }
  }
}));

// ä¼šè¯çŠ¶æ€ç®¡ç†
interface SessionStore {
  sessions: ChatSession[];
  currentSession: ChatSession | null;
  unreadStats: UnreadStats;
  filters: SessionFilters;
  isLoading: boolean;

  // Actions
  loadSessions: (accountId: string, filters?: SessionFilters) => Promise<void>;
  selectSession: (session: ChatSession) => void;
  markAsRead: (sessionId: string) => Promise<void>;
  markAllAsRead: (accountId: string) => Promise<void>;
  updateFilters: (filters: Partial<SessionFilters>) => void;
  subscribeToUpdates: (accountId: string) => () => void;
}

export const useSessionStore = create<SessionStore>((set, get) => ({
  sessions: [],
  currentSession: null,
  unreadStats: { totalUnread: 0, unreadSessionCount: 0, sessions: [] },
  filters: { unreadOnly: false },
  isLoading: false,

  loadSessions: async (accountId, filters) => {
    set({ isLoading: true });
    try {
      const result = await window.electron.invoke(SESSION_CHANNELS.GET_SESSIONS, {
        accountId,
        filters: { ...get().filters, ...filters }
      });

      if (result.success) {
        set({ sessions: result.data, isLoading: false });
      }
    } catch (error) {
      set({ isLoading: false });
      console.error('åŠ è½½ä¼šè¯å¤±è´¥:', error);
    }
  },

  selectSession: (session) => set({ currentSession: session }),

  markAsRead: async (sessionId) => {
    try {
      const [accountId, chatId] = sessionId.split('_');
      await window.electron.invoke(SESSION_CHANNELS.MARK_READ, {
        accountId,
        chatId
      });

      // æ›´æ–°æœ¬åœ°çŠ¶æ€
      set((state) => ({
        sessions: state.sessions.map(session =>
          session.id === sessionId
            ? { ...session, unreadCount: 0 }
            : session
        ),
        currentSession: state.currentSession?.id === sessionId
          ? { ...state.currentSession, unreadCount: 0 }
          : state.currentSession
      }));
    } catch (error) {
      console.error('æ ‡è®°å·²è¯»å¤±è´¥:', error);
    }
  },

  updateFilters: (newFilters) => set((state) => ({
    filters: { ...state.filters, ...newFilters }
  })),

  subscribeToUpdates: (accountId) => {
    const handleUpdate = (event: any, data: any) => {
      const { type, session } = data;

      if (type === 'session_update') {
        set((state) => ({
          sessions: state.sessions.map(s =>
            s.id === session.id ? { ...s, ...session } : s
          ),
          currentSession: state.currentSession?.id === session.id
            ? { ...state.currentSession, ...session }
            : state.currentSession
        }));
      }
    };

    window.electron.on(`session_update_${accountId}`, handleUpdate);

    return () => {
      window.electron.off(`session_update_${accountId}`, handleUpdate);
    };
  }
}));
```

---

## ğŸ¯ å®æ–½è·¯çº¿å›¾

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€ç¿»è¯‘åŠŸèƒ½ï¼ˆ2-3å‘¨ï¼‰

1. **ç¿»è¯‘å¼•æ“é›†æˆ**
   - é›†æˆ Google Translate API
   - é›†æˆ DeepL API
   - å®ç°å¼•æ“é™çº§æœºåˆ¶

2. **åŸºç¡€æ¶ˆæ¯ç¿»è¯‘**
   - æ‰©å±•ç°æœ‰ MessageActions
   - å®ç°è¯­è¨€æ£€æµ‹
   - æ·»åŠ ç¿»è¯‘ç¼“å­˜

3. **ç”¨æˆ·ç•Œé¢å¼€å‘**
   - ç¿»è¯‘è®¾ç½®é¢æ¿
   - å®æ—¶ç¿»è¯‘å¼€å…³
   - ç¿»è¯‘å†å²æŸ¥çœ‹

### ç¬¬äºŒé˜¶æ®µï¼šè‡ªåŠ¨åŒ–è°ƒåº¦ï¼ˆ3-4å‘¨ï¼‰

1. **æ¶ˆæ¯é˜Ÿåˆ—ç³»ç»Ÿ**
   - Redis + Bull Queue é›†æˆ
   - ä»»åŠ¡è°ƒåº¦å™¨å®ç°
   - å¤±è´¥é‡è¯•æœºåˆ¶

2. **å®šæ—¶å‘é€åŠŸèƒ½**
   - Cron è¡¨è¾¾å¼æ”¯æŒ
   - æ‰¹é‡æ¶ˆæ¯å‘é€
   - å‘é€è¿›åº¦è·Ÿè¸ª

3. **ç¾¤å‘åŠŸèƒ½ä¼˜åŒ–**
   - åˆ†æ‰¹å‘é€æ§åˆ¶
   - å‘é€é€Ÿç‡é™åˆ¶
   - å‘é€ç»“æœç»Ÿè®¡

### ç¬¬ä¸‰é˜¶æ®µï¼šä¼šè¯ç®¡ç†ï¼ˆ2-3å‘¨ï¼‰

1. **ä¼šè¯æ•°æ®æ¨¡å‹**
   - SQLite è¡¨ç»“æ„è®¾è®¡
   - ä¼šè¯çŠ¶æ€è¿½è¸ª
   - æœªè¯»æ¶ˆæ¯ç®¡ç†

2. **å®æ—¶ä¼šè¯ç›‘æ§**
   - WebSocket æ¨é€
   - Server-Sent Events
   - å‰ç«¯çŠ¶æ€åŒæ­¥

3. **ä¼šè¯ç­›é€‰å’Œæœç´¢**
   - å¤šç»´åº¦ç­›é€‰å™¨
   - å…¨æ–‡æœç´¢åŠŸèƒ½
   - é«˜çº§è¿‡æ»¤å™¨

### ç¬¬å››é˜¶æ®µï¼šè”ç³»äººç³»ç»Ÿï¼ˆ3-4å‘¨ï¼‰

1. **è”ç³»äººæ•°æ®ç®¡ç†**
   - è”ç³»äººä¿¡æ¯å­˜å‚¨
   - äº’åŠ¨ç»Ÿè®¡è¿½è¸ª
   - æƒ…æ„Ÿåˆ†æé›†æˆ

2. **æ™ºèƒ½å¤‡æ³¨åŠŸèƒ½**
   - è‡ªåŠ¨å¤‡æ³¨ç”Ÿæˆ
   - æ™ºèƒ½æ ‡ç­¾ç³»ç»Ÿ
   - å¤‡æ³¨æ¨¡æ¿ç®¡ç†

3. **é«˜çº§æœç´¢åŠŸèƒ½**
   - å…¨æ–‡æœç´¢ç´¢å¼•
   - å¤æ‚ç­›é€‰æ¡ä»¶
   - æœç´¢ç»“æœæ’åº

### ç¬¬äº”é˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆ2å‘¨ï¼‰

1. **ç¼“å­˜ä¼˜åŒ–**
   - ç¿»è¯‘ç»“æœç¼“å­˜
   - ä¼šè¯æ•°æ®ç¼“å­˜
   - è”ç³»äººä¿¡æ¯ç¼“å­˜

2. **æ•°æ®åº“ä¼˜åŒ–**
   - ç´¢å¼•ä¼˜åŒ–
   - æŸ¥è¯¢æ€§èƒ½è°ƒä¼˜
   - æ•°æ®åˆ†é¡µå¤„ç†

3. **å†…å­˜ç®¡ç†**
   - å¯¹è±¡æ± å®ç°
   - åƒåœ¾å›æ”¶ä¼˜åŒ–
   - å†…å­˜æ³„æ¼æ£€æµ‹

---

## ğŸ“ˆ é¢„æœŸæ”¶ç›Š

### åŠŸèƒ½æ”¶ç›Š

- **ç¿»è¯‘æ•ˆç‡æå‡ 80%**ï¼šè‡ªåŠ¨åŒ–ç¿»è¯‘æµç¨‹
- **æ¶ˆæ¯å‘é€æ•ˆç‡æå‡ 60%**ï¼šæ‰¹é‡å®šæ—¶å‘é€
- **å®¢æˆ·ç®¡ç†æ•ˆç‡æå‡ 70%**ï¼šæ™ºèƒ½å¤‡æ³¨å’Œæ ‡ç­¾
- **å“åº”é€Ÿåº¦æå‡ 50%**ï¼šå®æ—¶ä¼šè¯ç›‘æ§

### æŠ€æœ¯æ”¶ç›Š

- **æ¶æ„æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ä¾¿äºåŠŸèƒ½æ‰©å±•
- **ç³»ç»Ÿç¨³å®šæ€§**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- **ç”¨æˆ·ä½“éªŒ**ï¼šç›´è§‚çš„ç•Œé¢å’Œæµç•…çš„äº¤äº’
- **æ•°æ®å®‰å…¨**ï¼šæœ¬åœ°å­˜å‚¨å’ŒåŠ å¯†ä¼ è¾“

### å•†ä¸šä»·å€¼

- **é™ä½è¿è¥æˆæœ¬**ï¼šè‡ªåŠ¨åŒ–å‡å°‘äººå·¥å¹²é¢„
- **æå‡å®¢æˆ·æ»¡æ„åº¦**ï¼šå¿«é€Ÿå‡†ç¡®çš„å¤šè¯­è¨€æ²Ÿé€š
- **å¢å¼ºç«äº‰åŠ›**ï¼šå®Œæ•´çš„ç¿»è¯‘è‡ªåŠ¨åŒ–è§£å†³æ–¹æ¡ˆ
- **æ‰©å±•å¸‚åœºè¦†ç›–**ï¼šæ”¯æŒå¤šè¯­è¨€å›½é™…åŒ–

---

## ğŸ“ æ€»ç»“

è¿™ä»½æ˜“ç¿»è¯‘åŠŸèƒ½æ¶æ„è®¾è®¡åŸºäºç°æœ‰çš„ Telegram Web Auto Reply åŸºç¡€ï¼Œæä¾›äº†å®Œæ•´çš„ç¿»è¯‘è‡ªåŠ¨åŒ–è§£å†³æ–¹æ¡ˆã€‚é€šè¿‡**æ¨¡å—åŒ–è®¾è®¡**ã€**å¾®æœåŠ¡æ¶æ„**å’Œ**å®æ—¶é€šä¿¡**ï¼Œå®ç°äº†é«˜æ€§èƒ½ã€å¯æ‰©å±•çš„ç”¨æˆ·ä½“éªŒã€‚

### æ ¸å¿ƒä¼˜åŠ¿

1. **æŠ€æœ¯å…ˆè¿›æ€§**ï¼šå¤šå¼•æ“ç¿»è¯‘ã€æ™ºèƒ½è°ƒåº¦ã€å®æ—¶ç›‘æ§
2. **åŠŸèƒ½å®Œæ•´æ€§**ï¼šæ¶µç›–ç¿»è¯‘ã€å‘é€ã€ç®¡ç†ã€åˆ†æå…¨æµç¨‹
3. **ç”¨æˆ·ä½“éªŒä¼˜ç§€**ï¼šç›´è§‚ç•Œé¢ã€æ™ºèƒ½æé†’ã€ä¸€é”®æ“ä½œ
4. **æ‰©å±•æ€§å¼º**ï¼šæ¨¡å—åŒ–æ¶æ„ä¾¿äºåç»­åŠŸèƒ½æ‰©å±•

### å®æ–½å»ºè®®

1. **åˆ†é˜¶æ®µå®æ–½**ï¼šæŒ‰ç…§è·¯çº¿å›¾é€æ­¥æ¨è¿›ï¼Œé™ä½é£é™©
2. **æµ‹è¯•é©±åŠ¨**ï¼šæ¯ä¸ªæ¨¡å—éƒ½è¦æœ‰å®Œæ•´çš„æµ‹è¯•è¦†ç›–
3. **ç”¨æˆ·åé¦ˆ**ï¼šåŠæ—¶æ”¶é›†ç”¨æˆ·åé¦ˆï¼ŒæŒç»­ä¼˜åŒ–ä½“éªŒ
4. **æ€§èƒ½ç›‘æ§**ï¼šå»ºç«‹å®Œå–„çš„æ€§èƒ½ç›‘æ§å’ŒæŠ¥è­¦æœºåˆ¶

è¿™ä¸ªæ¶æ„è®¾è®¡ä¸º teleflow-desktop é¡¹ç›®æä¾›äº†å®Œæ•´çš„ç¿»è¯‘åŠŸèƒ½è“å›¾ï¼Œå¯ä»¥æ˜¾è‘—æå‡äº§å“çš„ç«äº‰åŠ›å’Œç”¨æˆ·ä»·å€¼ã€‚
